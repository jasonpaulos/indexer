// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"io"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/algorand/indexer/api/graph/model"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Account() AccountResolver
	AccountUpdateResponse() AccountUpdateResponseResolver
	ApplicationLocalState() ApplicationLocalStateResolver
	ApplicationParams() ApplicationParamsResolver
	AssetHolding() AssetHoldingResolver
	AssetParams() AssetParamsResolver
	MiniAssetHolding() MiniAssetHoldingResolver
	Query() QueryResolver
	Subscription() SubscriptionResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Account struct {
		Address                     func(childComplexity int) int
		Amount                      func(childComplexity int) int
		AmountWithoutPendingRewards func(childComplexity int) int
		AppLocalState               func(childComplexity int, id uint64) int
		AppsLocalState              func(childComplexity int) int
		AppsTotalExtraPages         func(childComplexity int) int
		AppsTotalSchema             func(childComplexity int) int
		Asset                       func(childComplexity int, id uint64) int
		Assets                      func(childComplexity int) int
		AuthAccount                 func(childComplexity int) int
		AuthAddr                    func(childComplexity int) int
		ClosedAtRound               func(childComplexity int) int
		CreatedApp                  func(childComplexity int, id uint64) int
		CreatedApps                 func(childComplexity int) int
		CreatedAsset                func(childComplexity int, id uint64) int
		CreatedAssets               func(childComplexity int) int
		CreatedAtRound              func(childComplexity int) int
		Deleted                     func(childComplexity int) int
		Participation               func(childComplexity int) int
		PendingRewards              func(childComplexity int) int
		RewardBase                  func(childComplexity int) int
		Rewards                     func(childComplexity int) int
		Round                       func(childComplexity int) int
		SigType                     func(childComplexity int) int
		Status                      func(childComplexity int) int
	}

	AccountParticipation struct {
		SelectionParticipationKey func(childComplexity int) int
		VoteFirstValid            func(childComplexity int) int
		VoteKeyDilution           func(childComplexity int) int
		VoteLastValid             func(childComplexity int) int
		VoteParticipationKey      func(childComplexity int) int
	}

	AccountResponse struct {
		Account      func(childComplexity int) int
		CurrentRound func(childComplexity int) int
	}

	AccountStateDelta struct {
		Address func(childComplexity int) int
		Delta   func(childComplexity int) int
	}

	AccountUpdateResponse struct {
		Account      func(childComplexity int) int
		Transactions func(childComplexity int) int
	}

	AccountsResponse struct {
		Accounts     func(childComplexity int) int
		CurrentRound func(childComplexity int) int
		NextToken    func(childComplexity int) int
	}

	Application struct {
		CreatedAtRound func(childComplexity int) int
		Deleted        func(childComplexity int) int
		DeletedAtRound func(childComplexity int) int
		ID             func(childComplexity int) int
		Params         func(childComplexity int) int
	}

	ApplicationLocalState struct {
		Application      func(childComplexity int) int
		ClosedOutAtRound func(childComplexity int) int
		Deleted          func(childComplexity int) int
		ID               func(childComplexity int) int
		KeyValue         func(childComplexity int) int
		OptedInAtRound   func(childComplexity int) int
		Schema           func(childComplexity int) int
	}

	ApplicationParams struct {
		ApprovalProgram   func(childComplexity int) int
		ClearStateProgram func(childComplexity int) int
		Creator           func(childComplexity int) int
		CreatorAccount    func(childComplexity int) int
		ExtraProgramPages func(childComplexity int) int
		GlobalState       func(childComplexity int) int
		GlobalStateSchema func(childComplexity int) int
		LocalStateSchema  func(childComplexity int) int
	}

	ApplicationResponse struct {
		Application  func(childComplexity int) int
		CurrentRound func(childComplexity int) int
	}

	ApplicationStateSchema struct {
		NumByteSlice func(childComplexity int) int
		NumUint      func(childComplexity int) int
	}

	ApplicationsResponse struct {
		Applications func(childComplexity int) int
		CurrentRound func(childComplexity int) int
		NextToken    func(childComplexity int) int
	}

	Asset struct {
		CreatedAtRound   func(childComplexity int) int
		Deleted          func(childComplexity int) int
		DestroyedAtRound func(childComplexity int) int
		ID               func(childComplexity int) int
		Params           func(childComplexity int) int
	}

	AssetBalancesResponse struct {
		Balances     func(childComplexity int) int
		CurrentRound func(childComplexity int) int
		NextToken    func(childComplexity int) int
	}

	AssetHolding struct {
		Amount          func(childComplexity int) int
		Asset           func(childComplexity int) int
		Creator         func(childComplexity int) int
		Deleted         func(childComplexity int) int
		Frozen          func(childComplexity int) int
		ID              func(childComplexity int) int
		OptedInAtRound  func(childComplexity int) int
		OptedOutAtRound func(childComplexity int) int
	}

	AssetParams struct {
		Clawback        func(childComplexity int) int
		ClawbackAccount func(childComplexity int) int
		Creator         func(childComplexity int) int
		CreatorAccount  func(childComplexity int) int
		Decimals        func(childComplexity int) int
		DefaultFrozen   func(childComplexity int) int
		Freeze          func(childComplexity int) int
		FreezeAccount   func(childComplexity int) int
		Manager         func(childComplexity int) int
		ManagerAccount  func(childComplexity int) int
		MetadataHash    func(childComplexity int) int
		Name            func(childComplexity int) int
		Reserve         func(childComplexity int) int
		ReserveAccount  func(childComplexity int) int
		Total           func(childComplexity int) int
		URL             func(childComplexity int) int
		UnitName        func(childComplexity int) int
	}

	AssetResponse struct {
		Asset        func(childComplexity int) int
		CurrentRound func(childComplexity int) int
	}

	AssetsResponse struct {
		Assets       func(childComplexity int) int
		CurrentRound func(childComplexity int) int
		NextToken    func(childComplexity int) int
	}

	Block struct {
		GenesisHash       func(childComplexity int) int
		GenesisID         func(childComplexity int) int
		PreviousBlockHash func(childComplexity int) int
		Rewards           func(childComplexity int) int
		Round             func(childComplexity int) int
		Seed              func(childComplexity int) int
		Timestamp         func(childComplexity int) int
		Transactions      func(childComplexity int) int
		TransactionsRoot  func(childComplexity int) int
		TxnCounter        func(childComplexity int) int
		UpgradeState      func(childComplexity int) int
		UpgradeVote       func(childComplexity int) int
	}

	BlockRewards struct {
		FeeSink                 func(childComplexity int) int
		RewardsCalculationRound func(childComplexity int) int
		RewardsLevel            func(childComplexity int) int
		RewardsPool             func(childComplexity int) int
		RewardsRate             func(childComplexity int) int
		RewardsResidue          func(childComplexity int) int
	}

	BlockUpgradeState struct {
		CurrentProtocol        func(childComplexity int) int
		NextProtocol           func(childComplexity int) int
		NextProtocolApprovals  func(childComplexity int) int
		NextProtocolSwitchOn   func(childComplexity int) int
		NextProtocolVoteBefore func(childComplexity int) int
	}

	BlockUpgradeVote struct {
		UpgradeApprove func(childComplexity int) int
		UpgradeDelay   func(childComplexity int) int
		UpgradePropose func(childComplexity int) int
	}

	EvalDelta struct {
		Action func(childComplexity int) int
		Bytes  func(childComplexity int) int
		Uint   func(childComplexity int) int
	}

	EvalDeltaKeyValue struct {
		Key   func(childComplexity int) int
		Value func(childComplexity int) int
	}

	HealthCheck struct {
		Data        func(childComplexity int) int
		DbAvailable func(childComplexity int) int
		Errors      func(childComplexity int) int
		IsMigrating func(childComplexity int) int
		Message     func(childComplexity int) int
		Round       func(childComplexity int) int
	}

	MiniAssetHolding struct {
		Account         func(childComplexity int) int
		Address         func(childComplexity int) int
		Amount          func(childComplexity int) int
		Deleted         func(childComplexity int) int
		Frozen          func(childComplexity int) int
		OptedInAtRound  func(childComplexity int) int
		OptedOutAtRound func(childComplexity int) int
	}

	Query struct {
		Account             func(childComplexity int, address string, includeAll *bool, round *uint64) int
		AccountTransactions func(childComplexity int, account string, afterTime *time.Time, assetID *uint64, beforeTime *time.Time, currencyGreaterThan *uint64, currencyLessThan *uint64, limit *uint64, maxRound *uint64, minRound *uint64, next *string, notePrefix []byte, rekeyTo *bool, round *uint64, sigType *model.SigType, txType *model.TxType, id *string) int
		Accounts            func(childComplexity int, applicationID *uint64, assetID *uint64, authAddr *string, currencyGreaterThan *uint64, currencyLessThan *uint64, includeAll *bool, limit *uint64, next *string, round *uint64) int
		Application         func(childComplexity int, id uint64, includeAll *bool) int
		Applications        func(childComplexity int, id *uint64, includeAll *bool, limit *uint64, next *string) int
		Asset               func(childComplexity int, id uint64, includeAll *bool) int
		AssetBalances       func(childComplexity int, assetID uint64, currencyGreaterThan *uint64, currencyLessThan *uint64, includeAll *bool, limit *uint64, next *string, round *uint64) int
		AssetTransactions   func(childComplexity int, address *string, addressRole *model.AddressRole, afterTime *time.Time, assetID uint64, beforeTime *time.Time, currencyGreaterThan *uint64, currencyLessThan *uint64, excludeCloseTo *bool, limit *uint64, maxRound *uint64, minRound *uint64, next *string, notePrefix []byte, rekeyTo *bool, round *uint64, sigType *model.SigType, txType *model.TxType, id *string) int
		Assets              func(childComplexity int, id *uint64, creator *string, includeAll *bool, limit *uint64, name *string, next *string, unit *string) int
		Block               func(childComplexity int, roundNumber uint64) int
		HealthCheck         func(childComplexity int) int
		Transaction         func(childComplexity int, id string) int
		Transactions        func(childComplexity int, address *string, addressRole *model.AddressRole, afterTime *time.Time, applicationID *uint64, assetID *uint64, beforeTime *time.Time, currencyGreaterThan *uint64, currencyLessThan *uint64, excludeCloseTo *bool, limit *uint64, maxRound *uint64, minRound *uint64, next *string, notePrefix []byte, rekeyTo *bool, round *uint64, sigType *model.SigType, txType *model.TxType, id *string) int
	}

	StateSchema struct {
		NumByteSlice func(childComplexity int) int
		NumUint      func(childComplexity int) int
	}

	Subscription struct {
		AccountUpdate func(childComplexity int, address string) int
		NewBlock      func(childComplexity int) int
	}

	TealKeyValue struct {
		Key   func(childComplexity int) int
		Value func(childComplexity int) int
	}

	TealValue struct {
		Bytes func(childComplexity int) int
		Type  func(childComplexity int) int
		Uint  func(childComplexity int) int
	}

	Transaction struct {
		ApplicationTransaction   func(childComplexity int) int
		AssetConfigTransaction   func(childComplexity int) int
		AssetFreezeTransaction   func(childComplexity int) int
		AssetTransferTransaction func(childComplexity int) int
		AuthAddr                 func(childComplexity int) int
		CloseRewards             func(childComplexity int) int
		ClosingAmount            func(childComplexity int) int
		ConfirmedRound           func(childComplexity int) int
		CreatedApplicationID     func(childComplexity int) int
		CreatedAssetID           func(childComplexity int) int
		Fee                      func(childComplexity int) int
		FirstValid               func(childComplexity int) int
		GenesisHash              func(childComplexity int) int
		GenesisID                func(childComplexity int) int
		GlobalStateDelta         func(childComplexity int) int
		Group                    func(childComplexity int) int
		ID                       func(childComplexity int) int
		IntraRoundOffset         func(childComplexity int) int
		KeyregTransaction        func(childComplexity int) int
		LastValid                func(childComplexity int) int
		Lease                    func(childComplexity int) int
		LocalStateDelta          func(childComplexity int) int
		Note                     func(childComplexity int) int
		PaymentTransaction       func(childComplexity int) int
		ReceiverRewards          func(childComplexity int) int
		RekeyTo                  func(childComplexity int) int
		RoundTime                func(childComplexity int) int
		Sender                   func(childComplexity int) int
		SenderRewards            func(childComplexity int) int
		Signature                func(childComplexity int) int
		TxType                   func(childComplexity int) int
	}

	TransactionApplication struct {
		Accounts          func(childComplexity int) int
		ApplicationArgs   func(childComplexity int) int
		ApplicationID     func(childComplexity int) int
		ApprovalProgram   func(childComplexity int) int
		ClearStateProgram func(childComplexity int) int
		ExtraProgramPages func(childComplexity int) int
		ForeignApps       func(childComplexity int) int
		ForeignAssets     func(childComplexity int) int
		GlobalStateSchema func(childComplexity int) int
		LocalStateSchema  func(childComplexity int) int
		OnCompletion      func(childComplexity int) int
	}

	TransactionAssetConfig struct {
		AssetID func(childComplexity int) int
		Params  func(childComplexity int) int
	}

	TransactionAssetFreeze struct {
		Address         func(childComplexity int) int
		AssetID         func(childComplexity int) int
		NewFreezeStatus func(childComplexity int) int
	}

	TransactionAssetTransfer struct {
		Amount      func(childComplexity int) int
		AssetID     func(childComplexity int) int
		CloseAmount func(childComplexity int) int
		CloseTo     func(childComplexity int) int
		Receiver    func(childComplexity int) int
		Sender      func(childComplexity int) int
	}

	TransactionKeyreg struct {
		NonParticipation          func(childComplexity int) int
		SelectionParticipationKey func(childComplexity int) int
		VoteFirstValid            func(childComplexity int) int
		VoteKeyDilution           func(childComplexity int) int
		VoteLastValid             func(childComplexity int) int
		VoteParticipationKey      func(childComplexity int) int
	}

	TransactionPayment struct {
		Amount           func(childComplexity int) int
		CloseAmount      func(childComplexity int) int
		CloseRemainderTo func(childComplexity int) int
		Receiver         func(childComplexity int) int
	}

	TransactionResponse struct {
		CurrentRound func(childComplexity int) int
		Transaction  func(childComplexity int) int
	}

	TransactionSignature struct {
		Logicsig func(childComplexity int) int
		Multisig func(childComplexity int) int
		Sig      func(childComplexity int) int
	}

	TransactionSignatureLogicsig struct {
		Args              func(childComplexity int) int
		Logic             func(childComplexity int) int
		MultisigSignature func(childComplexity int) int
		Signature         func(childComplexity int) int
	}

	TransactionSignatureMultisig struct {
		Subsignature func(childComplexity int) int
		Threshold    func(childComplexity int) int
		Version      func(childComplexity int) int
	}

	TransactionSignatureMultisigSubsignature struct {
		PublicKey func(childComplexity int) int
		Signature func(childComplexity int) int
	}

	TransactionsResponse struct {
		CurrentRound func(childComplexity int) int
		NextToken    func(childComplexity int) int
		Transactions func(childComplexity int) int
	}
}

type AccountResolver interface {
	AppLocalState(ctx context.Context, obj *model.Account, id uint64) (*model.ApplicationLocalState, error)

	Asset(ctx context.Context, obj *model.Account, id uint64) (*model.AssetHolding, error)

	AuthAccount(ctx context.Context, obj *model.Account) (*model.Account, error)

	CreatedApp(ctx context.Context, obj *model.Account, id uint64) (*model.Application, error)

	CreatedAsset(ctx context.Context, obj *model.Account, id uint64) (*model.Asset, error)
}
type AccountUpdateResponseResolver interface {
	Account(ctx context.Context, obj *model.AccountUpdateResponse) (*model.Account, error)
}
type ApplicationLocalStateResolver interface {
	Application(ctx context.Context, obj *model.ApplicationLocalState) (*model.Application, error)
}
type ApplicationParamsResolver interface {
	CreatorAccount(ctx context.Context, obj *model.ApplicationParams) (*model.Account, error)
}
type AssetHoldingResolver interface {
	Asset(ctx context.Context, obj *model.AssetHolding) (*model.Asset, error)
}
type AssetParamsResolver interface {
	ClawbackAccount(ctx context.Context, obj *model.AssetParams) (*model.Account, error)

	CreatorAccount(ctx context.Context, obj *model.AssetParams) (*model.Account, error)

	FreezeAccount(ctx context.Context, obj *model.AssetParams) (*model.Account, error)

	ManagerAccount(ctx context.Context, obj *model.AssetParams) (*model.Account, error)

	ReserveAccount(ctx context.Context, obj *model.AssetParams) (*model.Account, error)
}
type MiniAssetHoldingResolver interface {
	Account(ctx context.Context, obj *model.MiniAssetHolding) (*model.Account, error)
}
type QueryResolver interface {
	Block(ctx context.Context, roundNumber uint64) (*model.Block, error)
	HealthCheck(ctx context.Context) (*model.HealthCheck, error)
	Account(ctx context.Context, address string, includeAll *bool, round *uint64) (*model.AccountResponse, error)
	AccountTransactions(ctx context.Context, account string, afterTime *time.Time, assetID *uint64, beforeTime *time.Time, currencyGreaterThan *uint64, currencyLessThan *uint64, limit *uint64, maxRound *uint64, minRound *uint64, next *string, notePrefix []byte, rekeyTo *bool, round *uint64, sigType *model.SigType, txType *model.TxType, id *string) (*model.TransactionsResponse, error)
	Accounts(ctx context.Context, applicationID *uint64, assetID *uint64, authAddr *string, currencyGreaterThan *uint64, currencyLessThan *uint64, includeAll *bool, limit *uint64, next *string, round *uint64) (*model.AccountsResponse, error)
	Application(ctx context.Context, id uint64, includeAll *bool) (*model.ApplicationResponse, error)
	Applications(ctx context.Context, id *uint64, includeAll *bool, limit *uint64, next *string) (*model.ApplicationsResponse, error)
	Asset(ctx context.Context, id uint64, includeAll *bool) (*model.AssetResponse, error)
	AssetBalances(ctx context.Context, assetID uint64, currencyGreaterThan *uint64, currencyLessThan *uint64, includeAll *bool, limit *uint64, next *string, round *uint64) (*model.AssetBalancesResponse, error)
	AssetTransactions(ctx context.Context, address *string, addressRole *model.AddressRole, afterTime *time.Time, assetID uint64, beforeTime *time.Time, currencyGreaterThan *uint64, currencyLessThan *uint64, excludeCloseTo *bool, limit *uint64, maxRound *uint64, minRound *uint64, next *string, notePrefix []byte, rekeyTo *bool, round *uint64, sigType *model.SigType, txType *model.TxType, id *string) (*model.TransactionsResponse, error)
	Assets(ctx context.Context, id *uint64, creator *string, includeAll *bool, limit *uint64, name *string, next *string, unit *string) (*model.AssetsResponse, error)
	Transaction(ctx context.Context, id string) (*model.TransactionResponse, error)
	Transactions(ctx context.Context, address *string, addressRole *model.AddressRole, afterTime *time.Time, applicationID *uint64, assetID *uint64, beforeTime *time.Time, currencyGreaterThan *uint64, currencyLessThan *uint64, excludeCloseTo *bool, limit *uint64, maxRound *uint64, minRound *uint64, next *string, notePrefix []byte, rekeyTo *bool, round *uint64, sigType *model.SigType, txType *model.TxType, id *string) (*model.TransactionsResponse, error)
}
type SubscriptionResolver interface {
	NewBlock(ctx context.Context) (<-chan *model.Block, error)
	AccountUpdate(ctx context.Context, address string) (<-chan *model.AccountUpdateResponse, error)
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "Account.address":
		if e.complexity.Account.Address == nil {
			break
		}

		return e.complexity.Account.Address(childComplexity), true

	case "Account.amount":
		if e.complexity.Account.Amount == nil {
			break
		}

		return e.complexity.Account.Amount(childComplexity), true

	case "Account.amountWithoutPendingRewards":
		if e.complexity.Account.AmountWithoutPendingRewards == nil {
			break
		}

		return e.complexity.Account.AmountWithoutPendingRewards(childComplexity), true

	case "Account.appLocalState":
		if e.complexity.Account.AppLocalState == nil {
			break
		}

		args, err := ec.field_Account_appLocalState_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Account.AppLocalState(childComplexity, args["id"].(uint64)), true

	case "Account.appsLocalState":
		if e.complexity.Account.AppsLocalState == nil {
			break
		}

		return e.complexity.Account.AppsLocalState(childComplexity), true

	case "Account.appsTotalExtraPages":
		if e.complexity.Account.AppsTotalExtraPages == nil {
			break
		}

		return e.complexity.Account.AppsTotalExtraPages(childComplexity), true

	case "Account.appsTotalSchema":
		if e.complexity.Account.AppsTotalSchema == nil {
			break
		}

		return e.complexity.Account.AppsTotalSchema(childComplexity), true

	case "Account.asset":
		if e.complexity.Account.Asset == nil {
			break
		}

		args, err := ec.field_Account_asset_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Account.Asset(childComplexity, args["id"].(uint64)), true

	case "Account.assets":
		if e.complexity.Account.Assets == nil {
			break
		}

		return e.complexity.Account.Assets(childComplexity), true

	case "Account.authAccount":
		if e.complexity.Account.AuthAccount == nil {
			break
		}

		return e.complexity.Account.AuthAccount(childComplexity), true

	case "Account.authAddr":
		if e.complexity.Account.AuthAddr == nil {
			break
		}

		return e.complexity.Account.AuthAddr(childComplexity), true

	case "Account.closedAtRound":
		if e.complexity.Account.ClosedAtRound == nil {
			break
		}

		return e.complexity.Account.ClosedAtRound(childComplexity), true

	case "Account.createdApp":
		if e.complexity.Account.CreatedApp == nil {
			break
		}

		args, err := ec.field_Account_createdApp_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Account.CreatedApp(childComplexity, args["id"].(uint64)), true

	case "Account.createdApps":
		if e.complexity.Account.CreatedApps == nil {
			break
		}

		return e.complexity.Account.CreatedApps(childComplexity), true

	case "Account.createdAsset":
		if e.complexity.Account.CreatedAsset == nil {
			break
		}

		args, err := ec.field_Account_createdAsset_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Account.CreatedAsset(childComplexity, args["id"].(uint64)), true

	case "Account.createdAssets":
		if e.complexity.Account.CreatedAssets == nil {
			break
		}

		return e.complexity.Account.CreatedAssets(childComplexity), true

	case "Account.createdAtRound":
		if e.complexity.Account.CreatedAtRound == nil {
			break
		}

		return e.complexity.Account.CreatedAtRound(childComplexity), true

	case "Account.deleted":
		if e.complexity.Account.Deleted == nil {
			break
		}

		return e.complexity.Account.Deleted(childComplexity), true

	case "Account.participation":
		if e.complexity.Account.Participation == nil {
			break
		}

		return e.complexity.Account.Participation(childComplexity), true

	case "Account.pendingRewards":
		if e.complexity.Account.PendingRewards == nil {
			break
		}

		return e.complexity.Account.PendingRewards(childComplexity), true

	case "Account.rewardBase":
		if e.complexity.Account.RewardBase == nil {
			break
		}

		return e.complexity.Account.RewardBase(childComplexity), true

	case "Account.rewards":
		if e.complexity.Account.Rewards == nil {
			break
		}

		return e.complexity.Account.Rewards(childComplexity), true

	case "Account.round":
		if e.complexity.Account.Round == nil {
			break
		}

		return e.complexity.Account.Round(childComplexity), true

	case "Account.sigType":
		if e.complexity.Account.SigType == nil {
			break
		}

		return e.complexity.Account.SigType(childComplexity), true

	case "Account.status":
		if e.complexity.Account.Status == nil {
			break
		}

		return e.complexity.Account.Status(childComplexity), true

	case "AccountParticipation.selectionParticipationKey":
		if e.complexity.AccountParticipation.SelectionParticipationKey == nil {
			break
		}

		return e.complexity.AccountParticipation.SelectionParticipationKey(childComplexity), true

	case "AccountParticipation.voteFirstValid":
		if e.complexity.AccountParticipation.VoteFirstValid == nil {
			break
		}

		return e.complexity.AccountParticipation.VoteFirstValid(childComplexity), true

	case "AccountParticipation.voteKeyDilution":
		if e.complexity.AccountParticipation.VoteKeyDilution == nil {
			break
		}

		return e.complexity.AccountParticipation.VoteKeyDilution(childComplexity), true

	case "AccountParticipation.voteLastValid":
		if e.complexity.AccountParticipation.VoteLastValid == nil {
			break
		}

		return e.complexity.AccountParticipation.VoteLastValid(childComplexity), true

	case "AccountParticipation.voteParticipationKey":
		if e.complexity.AccountParticipation.VoteParticipationKey == nil {
			break
		}

		return e.complexity.AccountParticipation.VoteParticipationKey(childComplexity), true

	case "AccountResponse.account":
		if e.complexity.AccountResponse.Account == nil {
			break
		}

		return e.complexity.AccountResponse.Account(childComplexity), true

	case "AccountResponse.currentRound":
		if e.complexity.AccountResponse.CurrentRound == nil {
			break
		}

		return e.complexity.AccountResponse.CurrentRound(childComplexity), true

	case "AccountStateDelta.address":
		if e.complexity.AccountStateDelta.Address == nil {
			break
		}

		return e.complexity.AccountStateDelta.Address(childComplexity), true

	case "AccountStateDelta.delta":
		if e.complexity.AccountStateDelta.Delta == nil {
			break
		}

		return e.complexity.AccountStateDelta.Delta(childComplexity), true

	case "AccountUpdateResponse.account":
		if e.complexity.AccountUpdateResponse.Account == nil {
			break
		}

		return e.complexity.AccountUpdateResponse.Account(childComplexity), true

	case "AccountUpdateResponse.transactions":
		if e.complexity.AccountUpdateResponse.Transactions == nil {
			break
		}

		return e.complexity.AccountUpdateResponse.Transactions(childComplexity), true

	case "AccountsResponse.accounts":
		if e.complexity.AccountsResponse.Accounts == nil {
			break
		}

		return e.complexity.AccountsResponse.Accounts(childComplexity), true

	case "AccountsResponse.currentRound":
		if e.complexity.AccountsResponse.CurrentRound == nil {
			break
		}

		return e.complexity.AccountsResponse.CurrentRound(childComplexity), true

	case "AccountsResponse.nextToken":
		if e.complexity.AccountsResponse.NextToken == nil {
			break
		}

		return e.complexity.AccountsResponse.NextToken(childComplexity), true

	case "Application.createdAtRound":
		if e.complexity.Application.CreatedAtRound == nil {
			break
		}

		return e.complexity.Application.CreatedAtRound(childComplexity), true

	case "Application.deleted":
		if e.complexity.Application.Deleted == nil {
			break
		}

		return e.complexity.Application.Deleted(childComplexity), true

	case "Application.deletedAtRound":
		if e.complexity.Application.DeletedAtRound == nil {
			break
		}

		return e.complexity.Application.DeletedAtRound(childComplexity), true

	case "Application.id":
		if e.complexity.Application.ID == nil {
			break
		}

		return e.complexity.Application.ID(childComplexity), true

	case "Application.params":
		if e.complexity.Application.Params == nil {
			break
		}

		return e.complexity.Application.Params(childComplexity), true

	case "ApplicationLocalState.application":
		if e.complexity.ApplicationLocalState.Application == nil {
			break
		}

		return e.complexity.ApplicationLocalState.Application(childComplexity), true

	case "ApplicationLocalState.closedOutAtRound":
		if e.complexity.ApplicationLocalState.ClosedOutAtRound == nil {
			break
		}

		return e.complexity.ApplicationLocalState.ClosedOutAtRound(childComplexity), true

	case "ApplicationLocalState.deleted":
		if e.complexity.ApplicationLocalState.Deleted == nil {
			break
		}

		return e.complexity.ApplicationLocalState.Deleted(childComplexity), true

	case "ApplicationLocalState.id":
		if e.complexity.ApplicationLocalState.ID == nil {
			break
		}

		return e.complexity.ApplicationLocalState.ID(childComplexity), true

	case "ApplicationLocalState.keyValue":
		if e.complexity.ApplicationLocalState.KeyValue == nil {
			break
		}

		return e.complexity.ApplicationLocalState.KeyValue(childComplexity), true

	case "ApplicationLocalState.optedInAtRound":
		if e.complexity.ApplicationLocalState.OptedInAtRound == nil {
			break
		}

		return e.complexity.ApplicationLocalState.OptedInAtRound(childComplexity), true

	case "ApplicationLocalState.schema":
		if e.complexity.ApplicationLocalState.Schema == nil {
			break
		}

		return e.complexity.ApplicationLocalState.Schema(childComplexity), true

	case "ApplicationParams.approvalProgram":
		if e.complexity.ApplicationParams.ApprovalProgram == nil {
			break
		}

		return e.complexity.ApplicationParams.ApprovalProgram(childComplexity), true

	case "ApplicationParams.clearStateProgram":
		if e.complexity.ApplicationParams.ClearStateProgram == nil {
			break
		}

		return e.complexity.ApplicationParams.ClearStateProgram(childComplexity), true

	case "ApplicationParams.creator":
		if e.complexity.ApplicationParams.Creator == nil {
			break
		}

		return e.complexity.ApplicationParams.Creator(childComplexity), true

	case "ApplicationParams.creatorAccount":
		if e.complexity.ApplicationParams.CreatorAccount == nil {
			break
		}

		return e.complexity.ApplicationParams.CreatorAccount(childComplexity), true

	case "ApplicationParams.extraProgramPages":
		if e.complexity.ApplicationParams.ExtraProgramPages == nil {
			break
		}

		return e.complexity.ApplicationParams.ExtraProgramPages(childComplexity), true

	case "ApplicationParams.globalState":
		if e.complexity.ApplicationParams.GlobalState == nil {
			break
		}

		return e.complexity.ApplicationParams.GlobalState(childComplexity), true

	case "ApplicationParams.globalStateSchema":
		if e.complexity.ApplicationParams.GlobalStateSchema == nil {
			break
		}

		return e.complexity.ApplicationParams.GlobalStateSchema(childComplexity), true

	case "ApplicationParams.localStateSchema":
		if e.complexity.ApplicationParams.LocalStateSchema == nil {
			break
		}

		return e.complexity.ApplicationParams.LocalStateSchema(childComplexity), true

	case "ApplicationResponse.application":
		if e.complexity.ApplicationResponse.Application == nil {
			break
		}

		return e.complexity.ApplicationResponse.Application(childComplexity), true

	case "ApplicationResponse.currentRound":
		if e.complexity.ApplicationResponse.CurrentRound == nil {
			break
		}

		return e.complexity.ApplicationResponse.CurrentRound(childComplexity), true

	case "ApplicationStateSchema.numByteSlice":
		if e.complexity.ApplicationStateSchema.NumByteSlice == nil {
			break
		}

		return e.complexity.ApplicationStateSchema.NumByteSlice(childComplexity), true

	case "ApplicationStateSchema.numUint":
		if e.complexity.ApplicationStateSchema.NumUint == nil {
			break
		}

		return e.complexity.ApplicationStateSchema.NumUint(childComplexity), true

	case "ApplicationsResponse.applications":
		if e.complexity.ApplicationsResponse.Applications == nil {
			break
		}

		return e.complexity.ApplicationsResponse.Applications(childComplexity), true

	case "ApplicationsResponse.currentRound":
		if e.complexity.ApplicationsResponse.CurrentRound == nil {
			break
		}

		return e.complexity.ApplicationsResponse.CurrentRound(childComplexity), true

	case "ApplicationsResponse.nextToken":
		if e.complexity.ApplicationsResponse.NextToken == nil {
			break
		}

		return e.complexity.ApplicationsResponse.NextToken(childComplexity), true

	case "Asset.createdAtRound":
		if e.complexity.Asset.CreatedAtRound == nil {
			break
		}

		return e.complexity.Asset.CreatedAtRound(childComplexity), true

	case "Asset.deleted":
		if e.complexity.Asset.Deleted == nil {
			break
		}

		return e.complexity.Asset.Deleted(childComplexity), true

	case "Asset.destroyedAtRound":
		if e.complexity.Asset.DestroyedAtRound == nil {
			break
		}

		return e.complexity.Asset.DestroyedAtRound(childComplexity), true

	case "Asset.id":
		if e.complexity.Asset.ID == nil {
			break
		}

		return e.complexity.Asset.ID(childComplexity), true

	case "Asset.params":
		if e.complexity.Asset.Params == nil {
			break
		}

		return e.complexity.Asset.Params(childComplexity), true

	case "AssetBalancesResponse.balances":
		if e.complexity.AssetBalancesResponse.Balances == nil {
			break
		}

		return e.complexity.AssetBalancesResponse.Balances(childComplexity), true

	case "AssetBalancesResponse.currentRound":
		if e.complexity.AssetBalancesResponse.CurrentRound == nil {
			break
		}

		return e.complexity.AssetBalancesResponse.CurrentRound(childComplexity), true

	case "AssetBalancesResponse.nextToken":
		if e.complexity.AssetBalancesResponse.NextToken == nil {
			break
		}

		return e.complexity.AssetBalancesResponse.NextToken(childComplexity), true

	case "AssetHolding.amount":
		if e.complexity.AssetHolding.Amount == nil {
			break
		}

		return e.complexity.AssetHolding.Amount(childComplexity), true

	case "AssetHolding.asset":
		if e.complexity.AssetHolding.Asset == nil {
			break
		}

		return e.complexity.AssetHolding.Asset(childComplexity), true

	case "AssetHolding.creator":
		if e.complexity.AssetHolding.Creator == nil {
			break
		}

		return e.complexity.AssetHolding.Creator(childComplexity), true

	case "AssetHolding.deleted":
		if e.complexity.AssetHolding.Deleted == nil {
			break
		}

		return e.complexity.AssetHolding.Deleted(childComplexity), true

	case "AssetHolding.frozen":
		if e.complexity.AssetHolding.Frozen == nil {
			break
		}

		return e.complexity.AssetHolding.Frozen(childComplexity), true

	case "AssetHolding.id":
		if e.complexity.AssetHolding.ID == nil {
			break
		}

		return e.complexity.AssetHolding.ID(childComplexity), true

	case "AssetHolding.optedInAtRound":
		if e.complexity.AssetHolding.OptedInAtRound == nil {
			break
		}

		return e.complexity.AssetHolding.OptedInAtRound(childComplexity), true

	case "AssetHolding.optedOutAtRound":
		if e.complexity.AssetHolding.OptedOutAtRound == nil {
			break
		}

		return e.complexity.AssetHolding.OptedOutAtRound(childComplexity), true

	case "AssetParams.clawback":
		if e.complexity.AssetParams.Clawback == nil {
			break
		}

		return e.complexity.AssetParams.Clawback(childComplexity), true

	case "AssetParams.clawbackAccount":
		if e.complexity.AssetParams.ClawbackAccount == nil {
			break
		}

		return e.complexity.AssetParams.ClawbackAccount(childComplexity), true

	case "AssetParams.creator":
		if e.complexity.AssetParams.Creator == nil {
			break
		}

		return e.complexity.AssetParams.Creator(childComplexity), true

	case "AssetParams.creatorAccount":
		if e.complexity.AssetParams.CreatorAccount == nil {
			break
		}

		return e.complexity.AssetParams.CreatorAccount(childComplexity), true

	case "AssetParams.decimals":
		if e.complexity.AssetParams.Decimals == nil {
			break
		}

		return e.complexity.AssetParams.Decimals(childComplexity), true

	case "AssetParams.defaultFrozen":
		if e.complexity.AssetParams.DefaultFrozen == nil {
			break
		}

		return e.complexity.AssetParams.DefaultFrozen(childComplexity), true

	case "AssetParams.freeze":
		if e.complexity.AssetParams.Freeze == nil {
			break
		}

		return e.complexity.AssetParams.Freeze(childComplexity), true

	case "AssetParams.freezeAccount":
		if e.complexity.AssetParams.FreezeAccount == nil {
			break
		}

		return e.complexity.AssetParams.FreezeAccount(childComplexity), true

	case "AssetParams.manager":
		if e.complexity.AssetParams.Manager == nil {
			break
		}

		return e.complexity.AssetParams.Manager(childComplexity), true

	case "AssetParams.managerAccount":
		if e.complexity.AssetParams.ManagerAccount == nil {
			break
		}

		return e.complexity.AssetParams.ManagerAccount(childComplexity), true

	case "AssetParams.metadataHash":
		if e.complexity.AssetParams.MetadataHash == nil {
			break
		}

		return e.complexity.AssetParams.MetadataHash(childComplexity), true

	case "AssetParams.name":
		if e.complexity.AssetParams.Name == nil {
			break
		}

		return e.complexity.AssetParams.Name(childComplexity), true

	case "AssetParams.reserve":
		if e.complexity.AssetParams.Reserve == nil {
			break
		}

		return e.complexity.AssetParams.Reserve(childComplexity), true

	case "AssetParams.reserveAccount":
		if e.complexity.AssetParams.ReserveAccount == nil {
			break
		}

		return e.complexity.AssetParams.ReserveAccount(childComplexity), true

	case "AssetParams.total":
		if e.complexity.AssetParams.Total == nil {
			break
		}

		return e.complexity.AssetParams.Total(childComplexity), true

	case "AssetParams.url":
		if e.complexity.AssetParams.URL == nil {
			break
		}

		return e.complexity.AssetParams.URL(childComplexity), true

	case "AssetParams.unitName":
		if e.complexity.AssetParams.UnitName == nil {
			break
		}

		return e.complexity.AssetParams.UnitName(childComplexity), true

	case "AssetResponse.asset":
		if e.complexity.AssetResponse.Asset == nil {
			break
		}

		return e.complexity.AssetResponse.Asset(childComplexity), true

	case "AssetResponse.currentRound":
		if e.complexity.AssetResponse.CurrentRound == nil {
			break
		}

		return e.complexity.AssetResponse.CurrentRound(childComplexity), true

	case "AssetsResponse.assets":
		if e.complexity.AssetsResponse.Assets == nil {
			break
		}

		return e.complexity.AssetsResponse.Assets(childComplexity), true

	case "AssetsResponse.currentRound":
		if e.complexity.AssetsResponse.CurrentRound == nil {
			break
		}

		return e.complexity.AssetsResponse.CurrentRound(childComplexity), true

	case "AssetsResponse.nextToken":
		if e.complexity.AssetsResponse.NextToken == nil {
			break
		}

		return e.complexity.AssetsResponse.NextToken(childComplexity), true

	case "Block.genesisHash":
		if e.complexity.Block.GenesisHash == nil {
			break
		}

		return e.complexity.Block.GenesisHash(childComplexity), true

	case "Block.genesisId":
		if e.complexity.Block.GenesisID == nil {
			break
		}

		return e.complexity.Block.GenesisID(childComplexity), true

	case "Block.previousBlockHash":
		if e.complexity.Block.PreviousBlockHash == nil {
			break
		}

		return e.complexity.Block.PreviousBlockHash(childComplexity), true

	case "Block.rewards":
		if e.complexity.Block.Rewards == nil {
			break
		}

		return e.complexity.Block.Rewards(childComplexity), true

	case "Block.round":
		if e.complexity.Block.Round == nil {
			break
		}

		return e.complexity.Block.Round(childComplexity), true

	case "Block.seed":
		if e.complexity.Block.Seed == nil {
			break
		}

		return e.complexity.Block.Seed(childComplexity), true

	case "Block.timestamp":
		if e.complexity.Block.Timestamp == nil {
			break
		}

		return e.complexity.Block.Timestamp(childComplexity), true

	case "Block.transactions":
		if e.complexity.Block.Transactions == nil {
			break
		}

		return e.complexity.Block.Transactions(childComplexity), true

	case "Block.transactionsRoot":
		if e.complexity.Block.TransactionsRoot == nil {
			break
		}

		return e.complexity.Block.TransactionsRoot(childComplexity), true

	case "Block.txnCounter":
		if e.complexity.Block.TxnCounter == nil {
			break
		}

		return e.complexity.Block.TxnCounter(childComplexity), true

	case "Block.upgradeState":
		if e.complexity.Block.UpgradeState == nil {
			break
		}

		return e.complexity.Block.UpgradeState(childComplexity), true

	case "Block.upgradeVote":
		if e.complexity.Block.UpgradeVote == nil {
			break
		}

		return e.complexity.Block.UpgradeVote(childComplexity), true

	case "BlockRewards.feeSink":
		if e.complexity.BlockRewards.FeeSink == nil {
			break
		}

		return e.complexity.BlockRewards.FeeSink(childComplexity), true

	case "BlockRewards.rewardsCalculationRound":
		if e.complexity.BlockRewards.RewardsCalculationRound == nil {
			break
		}

		return e.complexity.BlockRewards.RewardsCalculationRound(childComplexity), true

	case "BlockRewards.rewardsLevel":
		if e.complexity.BlockRewards.RewardsLevel == nil {
			break
		}

		return e.complexity.BlockRewards.RewardsLevel(childComplexity), true

	case "BlockRewards.rewardsPool":
		if e.complexity.BlockRewards.RewardsPool == nil {
			break
		}

		return e.complexity.BlockRewards.RewardsPool(childComplexity), true

	case "BlockRewards.rewardsRate":
		if e.complexity.BlockRewards.RewardsRate == nil {
			break
		}

		return e.complexity.BlockRewards.RewardsRate(childComplexity), true

	case "BlockRewards.rewardsResidue":
		if e.complexity.BlockRewards.RewardsResidue == nil {
			break
		}

		return e.complexity.BlockRewards.RewardsResidue(childComplexity), true

	case "BlockUpgradeState.currentProtocol":
		if e.complexity.BlockUpgradeState.CurrentProtocol == nil {
			break
		}

		return e.complexity.BlockUpgradeState.CurrentProtocol(childComplexity), true

	case "BlockUpgradeState.nextProtocol":
		if e.complexity.BlockUpgradeState.NextProtocol == nil {
			break
		}

		return e.complexity.BlockUpgradeState.NextProtocol(childComplexity), true

	case "BlockUpgradeState.nextProtocolApprovals":
		if e.complexity.BlockUpgradeState.NextProtocolApprovals == nil {
			break
		}

		return e.complexity.BlockUpgradeState.NextProtocolApprovals(childComplexity), true

	case "BlockUpgradeState.nextProtocolSwitchOn":
		if e.complexity.BlockUpgradeState.NextProtocolSwitchOn == nil {
			break
		}

		return e.complexity.BlockUpgradeState.NextProtocolSwitchOn(childComplexity), true

	case "BlockUpgradeState.nextProtocolVoteBefore":
		if e.complexity.BlockUpgradeState.NextProtocolVoteBefore == nil {
			break
		}

		return e.complexity.BlockUpgradeState.NextProtocolVoteBefore(childComplexity), true

	case "BlockUpgradeVote.upgradeApprove":
		if e.complexity.BlockUpgradeVote.UpgradeApprove == nil {
			break
		}

		return e.complexity.BlockUpgradeVote.UpgradeApprove(childComplexity), true

	case "BlockUpgradeVote.upgradeDelay":
		if e.complexity.BlockUpgradeVote.UpgradeDelay == nil {
			break
		}

		return e.complexity.BlockUpgradeVote.UpgradeDelay(childComplexity), true

	case "BlockUpgradeVote.upgradePropose":
		if e.complexity.BlockUpgradeVote.UpgradePropose == nil {
			break
		}

		return e.complexity.BlockUpgradeVote.UpgradePropose(childComplexity), true

	case "EvalDelta.action":
		if e.complexity.EvalDelta.Action == nil {
			break
		}

		return e.complexity.EvalDelta.Action(childComplexity), true

	case "EvalDelta.bytes":
		if e.complexity.EvalDelta.Bytes == nil {
			break
		}

		return e.complexity.EvalDelta.Bytes(childComplexity), true

	case "EvalDelta.uint":
		if e.complexity.EvalDelta.Uint == nil {
			break
		}

		return e.complexity.EvalDelta.Uint(childComplexity), true

	case "EvalDeltaKeyValue.key":
		if e.complexity.EvalDeltaKeyValue.Key == nil {
			break
		}

		return e.complexity.EvalDeltaKeyValue.Key(childComplexity), true

	case "EvalDeltaKeyValue.value":
		if e.complexity.EvalDeltaKeyValue.Value == nil {
			break
		}

		return e.complexity.EvalDeltaKeyValue.Value(childComplexity), true

	case "HealthCheck.data":
		if e.complexity.HealthCheck.Data == nil {
			break
		}

		return e.complexity.HealthCheck.Data(childComplexity), true

	case "HealthCheck.dbAvailable":
		if e.complexity.HealthCheck.DbAvailable == nil {
			break
		}

		return e.complexity.HealthCheck.DbAvailable(childComplexity), true

	case "HealthCheck.errors":
		if e.complexity.HealthCheck.Errors == nil {
			break
		}

		return e.complexity.HealthCheck.Errors(childComplexity), true

	case "HealthCheck.isMigrating":
		if e.complexity.HealthCheck.IsMigrating == nil {
			break
		}

		return e.complexity.HealthCheck.IsMigrating(childComplexity), true

	case "HealthCheck.message":
		if e.complexity.HealthCheck.Message == nil {
			break
		}

		return e.complexity.HealthCheck.Message(childComplexity), true

	case "HealthCheck.round":
		if e.complexity.HealthCheck.Round == nil {
			break
		}

		return e.complexity.HealthCheck.Round(childComplexity), true

	case "MiniAssetHolding.account":
		if e.complexity.MiniAssetHolding.Account == nil {
			break
		}

		return e.complexity.MiniAssetHolding.Account(childComplexity), true

	case "MiniAssetHolding.address":
		if e.complexity.MiniAssetHolding.Address == nil {
			break
		}

		return e.complexity.MiniAssetHolding.Address(childComplexity), true

	case "MiniAssetHolding.amount":
		if e.complexity.MiniAssetHolding.Amount == nil {
			break
		}

		return e.complexity.MiniAssetHolding.Amount(childComplexity), true

	case "MiniAssetHolding.deleted":
		if e.complexity.MiniAssetHolding.Deleted == nil {
			break
		}

		return e.complexity.MiniAssetHolding.Deleted(childComplexity), true

	case "MiniAssetHolding.frozen":
		if e.complexity.MiniAssetHolding.Frozen == nil {
			break
		}

		return e.complexity.MiniAssetHolding.Frozen(childComplexity), true

	case "MiniAssetHolding.optedInAtRound":
		if e.complexity.MiniAssetHolding.OptedInAtRound == nil {
			break
		}

		return e.complexity.MiniAssetHolding.OptedInAtRound(childComplexity), true

	case "MiniAssetHolding.optedOutAtRound":
		if e.complexity.MiniAssetHolding.OptedOutAtRound == nil {
			break
		}

		return e.complexity.MiniAssetHolding.OptedOutAtRound(childComplexity), true

	case "Query.account":
		if e.complexity.Query.Account == nil {
			break
		}

		args, err := ec.field_Query_account_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Account(childComplexity, args["address"].(string), args["includeAll"].(*bool), args["round"].(*uint64)), true

	case "Query.accountTransactions":
		if e.complexity.Query.AccountTransactions == nil {
			break
		}

		args, err := ec.field_Query_accountTransactions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AccountTransactions(childComplexity, args["account"].(string), args["afterTime"].(*time.Time), args["assetId"].(*uint64), args["beforeTime"].(*time.Time), args["currencyGreaterThan"].(*uint64), args["currencyLessThan"].(*uint64), args["limit"].(*uint64), args["maxRound"].(*uint64), args["minRound"].(*uint64), args["next"].(*string), args["notePrefix"].([]byte), args["rekeyTo"].(*bool), args["round"].(*uint64), args["sigType"].(*model.SigType), args["txType"].(*model.TxType), args["id"].(*string)), true

	case "Query.accounts":
		if e.complexity.Query.Accounts == nil {
			break
		}

		args, err := ec.field_Query_accounts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Accounts(childComplexity, args["applicationId"].(*uint64), args["assetId"].(*uint64), args["authAddr"].(*string), args["currencyGreaterThan"].(*uint64), args["currencyLessThan"].(*uint64), args["includeAll"].(*bool), args["limit"].(*uint64), args["next"].(*string), args["round"].(*uint64)), true

	case "Query.application":
		if e.complexity.Query.Application == nil {
			break
		}

		args, err := ec.field_Query_application_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Application(childComplexity, args["id"].(uint64), args["includeAll"].(*bool)), true

	case "Query.applications":
		if e.complexity.Query.Applications == nil {
			break
		}

		args, err := ec.field_Query_applications_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Applications(childComplexity, args["id"].(*uint64), args["includeAll"].(*bool), args["limit"].(*uint64), args["next"].(*string)), true

	case "Query.asset":
		if e.complexity.Query.Asset == nil {
			break
		}

		args, err := ec.field_Query_asset_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Asset(childComplexity, args["id"].(uint64), args["includeAll"].(*bool)), true

	case "Query.assetBalances":
		if e.complexity.Query.AssetBalances == nil {
			break
		}

		args, err := ec.field_Query_assetBalances_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AssetBalances(childComplexity, args["assetId"].(uint64), args["currencyGreaterThan"].(*uint64), args["currencyLessThan"].(*uint64), args["includeAll"].(*bool), args["limit"].(*uint64), args["next"].(*string), args["round"].(*uint64)), true

	case "Query.assetTransactions":
		if e.complexity.Query.AssetTransactions == nil {
			break
		}

		args, err := ec.field_Query_assetTransactions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AssetTransactions(childComplexity, args["address"].(*string), args["addressRole"].(*model.AddressRole), args["afterTime"].(*time.Time), args["assetId"].(uint64), args["beforeTime"].(*time.Time), args["currencyGreaterThan"].(*uint64), args["currencyLessThan"].(*uint64), args["excludeCloseTo"].(*bool), args["limit"].(*uint64), args["maxRound"].(*uint64), args["minRound"].(*uint64), args["next"].(*string), args["notePrefix"].([]byte), args["rekeyTo"].(*bool), args["round"].(*uint64), args["sigType"].(*model.SigType), args["txType"].(*model.TxType), args["id"].(*string)), true

	case "Query.assets":
		if e.complexity.Query.Assets == nil {
			break
		}

		args, err := ec.field_Query_assets_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Assets(childComplexity, args["id"].(*uint64), args["creator"].(*string), args["includeAll"].(*bool), args["limit"].(*uint64), args["name"].(*string), args["next"].(*string), args["unit"].(*string)), true

	case "Query.block":
		if e.complexity.Query.Block == nil {
			break
		}

		args, err := ec.field_Query_block_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Block(childComplexity, args["roundNumber"].(uint64)), true

	case "Query.healthCheck":
		if e.complexity.Query.HealthCheck == nil {
			break
		}

		return e.complexity.Query.HealthCheck(childComplexity), true

	case "Query.transaction":
		if e.complexity.Query.Transaction == nil {
			break
		}

		args, err := ec.field_Query_transaction_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Transaction(childComplexity, args["id"].(string)), true

	case "Query.transactions":
		if e.complexity.Query.Transactions == nil {
			break
		}

		args, err := ec.field_Query_transactions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Transactions(childComplexity, args["address"].(*string), args["addressRole"].(*model.AddressRole), args["afterTime"].(*time.Time), args["applicationId"].(*uint64), args["assetId"].(*uint64), args["beforeTime"].(*time.Time), args["currencyGreaterThan"].(*uint64), args["currencyLessThan"].(*uint64), args["excludeCloseTo"].(*bool), args["limit"].(*uint64), args["maxRound"].(*uint64), args["minRound"].(*uint64), args["next"].(*string), args["notePrefix"].([]byte), args["rekeyTo"].(*bool), args["round"].(*uint64), args["sigType"].(*model.SigType), args["txType"].(*model.TxType), args["id"].(*string)), true

	case "StateSchema.numByteSlice":
		if e.complexity.StateSchema.NumByteSlice == nil {
			break
		}

		return e.complexity.StateSchema.NumByteSlice(childComplexity), true

	case "StateSchema.numUint":
		if e.complexity.StateSchema.NumUint == nil {
			break
		}

		return e.complexity.StateSchema.NumUint(childComplexity), true

	case "Subscription.accountUpdate":
		if e.complexity.Subscription.AccountUpdate == nil {
			break
		}

		args, err := ec.field_Subscription_accountUpdate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.AccountUpdate(childComplexity, args["address"].(string)), true

	case "Subscription.newBlock":
		if e.complexity.Subscription.NewBlock == nil {
			break
		}

		return e.complexity.Subscription.NewBlock(childComplexity), true

	case "TealKeyValue.key":
		if e.complexity.TealKeyValue.Key == nil {
			break
		}

		return e.complexity.TealKeyValue.Key(childComplexity), true

	case "TealKeyValue.value":
		if e.complexity.TealKeyValue.Value == nil {
			break
		}

		return e.complexity.TealKeyValue.Value(childComplexity), true

	case "TealValue.bytes":
		if e.complexity.TealValue.Bytes == nil {
			break
		}

		return e.complexity.TealValue.Bytes(childComplexity), true

	case "TealValue.type":
		if e.complexity.TealValue.Type == nil {
			break
		}

		return e.complexity.TealValue.Type(childComplexity), true

	case "TealValue.uint":
		if e.complexity.TealValue.Uint == nil {
			break
		}

		return e.complexity.TealValue.Uint(childComplexity), true

	case "Transaction.applicationTransaction":
		if e.complexity.Transaction.ApplicationTransaction == nil {
			break
		}

		return e.complexity.Transaction.ApplicationTransaction(childComplexity), true

	case "Transaction.assetConfigTransaction":
		if e.complexity.Transaction.AssetConfigTransaction == nil {
			break
		}

		return e.complexity.Transaction.AssetConfigTransaction(childComplexity), true

	case "Transaction.assetFreezeTransaction":
		if e.complexity.Transaction.AssetFreezeTransaction == nil {
			break
		}

		return e.complexity.Transaction.AssetFreezeTransaction(childComplexity), true

	case "Transaction.assetTransferTransaction":
		if e.complexity.Transaction.AssetTransferTransaction == nil {
			break
		}

		return e.complexity.Transaction.AssetTransferTransaction(childComplexity), true

	case "Transaction.authAddr":
		if e.complexity.Transaction.AuthAddr == nil {
			break
		}

		return e.complexity.Transaction.AuthAddr(childComplexity), true

	case "Transaction.closeRewards":
		if e.complexity.Transaction.CloseRewards == nil {
			break
		}

		return e.complexity.Transaction.CloseRewards(childComplexity), true

	case "Transaction.closingAmount":
		if e.complexity.Transaction.ClosingAmount == nil {
			break
		}

		return e.complexity.Transaction.ClosingAmount(childComplexity), true

	case "Transaction.confirmedRound":
		if e.complexity.Transaction.ConfirmedRound == nil {
			break
		}

		return e.complexity.Transaction.ConfirmedRound(childComplexity), true

	case "Transaction.createdApplicationId":
		if e.complexity.Transaction.CreatedApplicationID == nil {
			break
		}

		return e.complexity.Transaction.CreatedApplicationID(childComplexity), true

	case "Transaction.createdAssetId":
		if e.complexity.Transaction.CreatedAssetID == nil {
			break
		}

		return e.complexity.Transaction.CreatedAssetID(childComplexity), true

	case "Transaction.fee":
		if e.complexity.Transaction.Fee == nil {
			break
		}

		return e.complexity.Transaction.Fee(childComplexity), true

	case "Transaction.firstValid":
		if e.complexity.Transaction.FirstValid == nil {
			break
		}

		return e.complexity.Transaction.FirstValid(childComplexity), true

	case "Transaction.genesisHash":
		if e.complexity.Transaction.GenesisHash == nil {
			break
		}

		return e.complexity.Transaction.GenesisHash(childComplexity), true

	case "Transaction.genesisId":
		if e.complexity.Transaction.GenesisID == nil {
			break
		}

		return e.complexity.Transaction.GenesisID(childComplexity), true

	case "Transaction.globalStateDelta":
		if e.complexity.Transaction.GlobalStateDelta == nil {
			break
		}

		return e.complexity.Transaction.GlobalStateDelta(childComplexity), true

	case "Transaction.group":
		if e.complexity.Transaction.Group == nil {
			break
		}

		return e.complexity.Transaction.Group(childComplexity), true

	case "Transaction.id":
		if e.complexity.Transaction.ID == nil {
			break
		}

		return e.complexity.Transaction.ID(childComplexity), true

	case "Transaction.intraRoundOffset":
		if e.complexity.Transaction.IntraRoundOffset == nil {
			break
		}

		return e.complexity.Transaction.IntraRoundOffset(childComplexity), true

	case "Transaction.keyregTransaction":
		if e.complexity.Transaction.KeyregTransaction == nil {
			break
		}

		return e.complexity.Transaction.KeyregTransaction(childComplexity), true

	case "Transaction.lastValid":
		if e.complexity.Transaction.LastValid == nil {
			break
		}

		return e.complexity.Transaction.LastValid(childComplexity), true

	case "Transaction.lease":
		if e.complexity.Transaction.Lease == nil {
			break
		}

		return e.complexity.Transaction.Lease(childComplexity), true

	case "Transaction.localStateDelta":
		if e.complexity.Transaction.LocalStateDelta == nil {
			break
		}

		return e.complexity.Transaction.LocalStateDelta(childComplexity), true

	case "Transaction.note":
		if e.complexity.Transaction.Note == nil {
			break
		}

		return e.complexity.Transaction.Note(childComplexity), true

	case "Transaction.paymentTransaction":
		if e.complexity.Transaction.PaymentTransaction == nil {
			break
		}

		return e.complexity.Transaction.PaymentTransaction(childComplexity), true

	case "Transaction.receiverRewards":
		if e.complexity.Transaction.ReceiverRewards == nil {
			break
		}

		return e.complexity.Transaction.ReceiverRewards(childComplexity), true

	case "Transaction.rekeyTo":
		if e.complexity.Transaction.RekeyTo == nil {
			break
		}

		return e.complexity.Transaction.RekeyTo(childComplexity), true

	case "Transaction.roundTime":
		if e.complexity.Transaction.RoundTime == nil {
			break
		}

		return e.complexity.Transaction.RoundTime(childComplexity), true

	case "Transaction.sender":
		if e.complexity.Transaction.Sender == nil {
			break
		}

		return e.complexity.Transaction.Sender(childComplexity), true

	case "Transaction.senderRewards":
		if e.complexity.Transaction.SenderRewards == nil {
			break
		}

		return e.complexity.Transaction.SenderRewards(childComplexity), true

	case "Transaction.signature":
		if e.complexity.Transaction.Signature == nil {
			break
		}

		return e.complexity.Transaction.Signature(childComplexity), true

	case "Transaction.txType":
		if e.complexity.Transaction.TxType == nil {
			break
		}

		return e.complexity.Transaction.TxType(childComplexity), true

	case "TransactionApplication.accounts":
		if e.complexity.TransactionApplication.Accounts == nil {
			break
		}

		return e.complexity.TransactionApplication.Accounts(childComplexity), true

	case "TransactionApplication.applicationArgs":
		if e.complexity.TransactionApplication.ApplicationArgs == nil {
			break
		}

		return e.complexity.TransactionApplication.ApplicationArgs(childComplexity), true

	case "TransactionApplication.applicationId":
		if e.complexity.TransactionApplication.ApplicationID == nil {
			break
		}

		return e.complexity.TransactionApplication.ApplicationID(childComplexity), true

	case "TransactionApplication.approvalProgram":
		if e.complexity.TransactionApplication.ApprovalProgram == nil {
			break
		}

		return e.complexity.TransactionApplication.ApprovalProgram(childComplexity), true

	case "TransactionApplication.clearStateProgram":
		if e.complexity.TransactionApplication.ClearStateProgram == nil {
			break
		}

		return e.complexity.TransactionApplication.ClearStateProgram(childComplexity), true

	case "TransactionApplication.extraProgramPages":
		if e.complexity.TransactionApplication.ExtraProgramPages == nil {
			break
		}

		return e.complexity.TransactionApplication.ExtraProgramPages(childComplexity), true

	case "TransactionApplication.foreignApps":
		if e.complexity.TransactionApplication.ForeignApps == nil {
			break
		}

		return e.complexity.TransactionApplication.ForeignApps(childComplexity), true

	case "TransactionApplication.foreignAssets":
		if e.complexity.TransactionApplication.ForeignAssets == nil {
			break
		}

		return e.complexity.TransactionApplication.ForeignAssets(childComplexity), true

	case "TransactionApplication.globalStateSchema":
		if e.complexity.TransactionApplication.GlobalStateSchema == nil {
			break
		}

		return e.complexity.TransactionApplication.GlobalStateSchema(childComplexity), true

	case "TransactionApplication.localStateSchema":
		if e.complexity.TransactionApplication.LocalStateSchema == nil {
			break
		}

		return e.complexity.TransactionApplication.LocalStateSchema(childComplexity), true

	case "TransactionApplication.onCompletion":
		if e.complexity.TransactionApplication.OnCompletion == nil {
			break
		}

		return e.complexity.TransactionApplication.OnCompletion(childComplexity), true

	case "TransactionAssetConfig.assetId":
		if e.complexity.TransactionAssetConfig.AssetID == nil {
			break
		}

		return e.complexity.TransactionAssetConfig.AssetID(childComplexity), true

	case "TransactionAssetConfig.params":
		if e.complexity.TransactionAssetConfig.Params == nil {
			break
		}

		return e.complexity.TransactionAssetConfig.Params(childComplexity), true

	case "TransactionAssetFreeze.address":
		if e.complexity.TransactionAssetFreeze.Address == nil {
			break
		}

		return e.complexity.TransactionAssetFreeze.Address(childComplexity), true

	case "TransactionAssetFreeze.assetId":
		if e.complexity.TransactionAssetFreeze.AssetID == nil {
			break
		}

		return e.complexity.TransactionAssetFreeze.AssetID(childComplexity), true

	case "TransactionAssetFreeze.newFreezeStatus":
		if e.complexity.TransactionAssetFreeze.NewFreezeStatus == nil {
			break
		}

		return e.complexity.TransactionAssetFreeze.NewFreezeStatus(childComplexity), true

	case "TransactionAssetTransfer.amount":
		if e.complexity.TransactionAssetTransfer.Amount == nil {
			break
		}

		return e.complexity.TransactionAssetTransfer.Amount(childComplexity), true

	case "TransactionAssetTransfer.assetId":
		if e.complexity.TransactionAssetTransfer.AssetID == nil {
			break
		}

		return e.complexity.TransactionAssetTransfer.AssetID(childComplexity), true

	case "TransactionAssetTransfer.closeAmount":
		if e.complexity.TransactionAssetTransfer.CloseAmount == nil {
			break
		}

		return e.complexity.TransactionAssetTransfer.CloseAmount(childComplexity), true

	case "TransactionAssetTransfer.closeTo":
		if e.complexity.TransactionAssetTransfer.CloseTo == nil {
			break
		}

		return e.complexity.TransactionAssetTransfer.CloseTo(childComplexity), true

	case "TransactionAssetTransfer.receiver":
		if e.complexity.TransactionAssetTransfer.Receiver == nil {
			break
		}

		return e.complexity.TransactionAssetTransfer.Receiver(childComplexity), true

	case "TransactionAssetTransfer.sender":
		if e.complexity.TransactionAssetTransfer.Sender == nil {
			break
		}

		return e.complexity.TransactionAssetTransfer.Sender(childComplexity), true

	case "TransactionKeyreg.nonParticipation":
		if e.complexity.TransactionKeyreg.NonParticipation == nil {
			break
		}

		return e.complexity.TransactionKeyreg.NonParticipation(childComplexity), true

	case "TransactionKeyreg.selectionParticipationKey":
		if e.complexity.TransactionKeyreg.SelectionParticipationKey == nil {
			break
		}

		return e.complexity.TransactionKeyreg.SelectionParticipationKey(childComplexity), true

	case "TransactionKeyreg.voteFirstValid":
		if e.complexity.TransactionKeyreg.VoteFirstValid == nil {
			break
		}

		return e.complexity.TransactionKeyreg.VoteFirstValid(childComplexity), true

	case "TransactionKeyreg.voteKeyDilution":
		if e.complexity.TransactionKeyreg.VoteKeyDilution == nil {
			break
		}

		return e.complexity.TransactionKeyreg.VoteKeyDilution(childComplexity), true

	case "TransactionKeyreg.voteLastValid":
		if e.complexity.TransactionKeyreg.VoteLastValid == nil {
			break
		}

		return e.complexity.TransactionKeyreg.VoteLastValid(childComplexity), true

	case "TransactionKeyreg.voteParticipationKey":
		if e.complexity.TransactionKeyreg.VoteParticipationKey == nil {
			break
		}

		return e.complexity.TransactionKeyreg.VoteParticipationKey(childComplexity), true

	case "TransactionPayment.amount":
		if e.complexity.TransactionPayment.Amount == nil {
			break
		}

		return e.complexity.TransactionPayment.Amount(childComplexity), true

	case "TransactionPayment.closeAmount":
		if e.complexity.TransactionPayment.CloseAmount == nil {
			break
		}

		return e.complexity.TransactionPayment.CloseAmount(childComplexity), true

	case "TransactionPayment.closeRemainderTo":
		if e.complexity.TransactionPayment.CloseRemainderTo == nil {
			break
		}

		return e.complexity.TransactionPayment.CloseRemainderTo(childComplexity), true

	case "TransactionPayment.receiver":
		if e.complexity.TransactionPayment.Receiver == nil {
			break
		}

		return e.complexity.TransactionPayment.Receiver(childComplexity), true

	case "TransactionResponse.currentRound":
		if e.complexity.TransactionResponse.CurrentRound == nil {
			break
		}

		return e.complexity.TransactionResponse.CurrentRound(childComplexity), true

	case "TransactionResponse.transaction":
		if e.complexity.TransactionResponse.Transaction == nil {
			break
		}

		return e.complexity.TransactionResponse.Transaction(childComplexity), true

	case "TransactionSignature.logicsig":
		if e.complexity.TransactionSignature.Logicsig == nil {
			break
		}

		return e.complexity.TransactionSignature.Logicsig(childComplexity), true

	case "TransactionSignature.multisig":
		if e.complexity.TransactionSignature.Multisig == nil {
			break
		}

		return e.complexity.TransactionSignature.Multisig(childComplexity), true

	case "TransactionSignature.sig":
		if e.complexity.TransactionSignature.Sig == nil {
			break
		}

		return e.complexity.TransactionSignature.Sig(childComplexity), true

	case "TransactionSignatureLogicsig.args":
		if e.complexity.TransactionSignatureLogicsig.Args == nil {
			break
		}

		return e.complexity.TransactionSignatureLogicsig.Args(childComplexity), true

	case "TransactionSignatureLogicsig.logic":
		if e.complexity.TransactionSignatureLogicsig.Logic == nil {
			break
		}

		return e.complexity.TransactionSignatureLogicsig.Logic(childComplexity), true

	case "TransactionSignatureLogicsig.multisigSignature":
		if e.complexity.TransactionSignatureLogicsig.MultisigSignature == nil {
			break
		}

		return e.complexity.TransactionSignatureLogicsig.MultisigSignature(childComplexity), true

	case "TransactionSignatureLogicsig.signature":
		if e.complexity.TransactionSignatureLogicsig.Signature == nil {
			break
		}

		return e.complexity.TransactionSignatureLogicsig.Signature(childComplexity), true

	case "TransactionSignatureMultisig.subsignature":
		if e.complexity.TransactionSignatureMultisig.Subsignature == nil {
			break
		}

		return e.complexity.TransactionSignatureMultisig.Subsignature(childComplexity), true

	case "TransactionSignatureMultisig.threshold":
		if e.complexity.TransactionSignatureMultisig.Threshold == nil {
			break
		}

		return e.complexity.TransactionSignatureMultisig.Threshold(childComplexity), true

	case "TransactionSignatureMultisig.version":
		if e.complexity.TransactionSignatureMultisig.Version == nil {
			break
		}

		return e.complexity.TransactionSignatureMultisig.Version(childComplexity), true

	case "TransactionSignatureMultisigSubsignature.publicKey":
		if e.complexity.TransactionSignatureMultisigSubsignature.PublicKey == nil {
			break
		}

		return e.complexity.TransactionSignatureMultisigSubsignature.PublicKey(childComplexity), true

	case "TransactionSignatureMultisigSubsignature.signature":
		if e.complexity.TransactionSignatureMultisigSubsignature.Signature == nil {
			break
		}

		return e.complexity.TransactionSignatureMultisigSubsignature.Signature(childComplexity), true

	case "TransactionsResponse.currentRound":
		if e.complexity.TransactionsResponse.CurrentRound == nil {
			break
		}

		return e.complexity.TransactionsResponse.CurrentRound(childComplexity), true

	case "TransactionsResponse.nextToken":
		if e.complexity.TransactionsResponse.NextToken == nil {
			break
		}

		return e.complexity.TransactionsResponse.NextToken(childComplexity), true

	case "TransactionsResponse.transactions":
		if e.complexity.TransactionsResponse.Transactions == nil {
			break
		}

		return e.complexity.TransactionsResponse.Transactions(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Subscription:
		next := ec._Subscription(ctx, rc.Operation.SelectionSet)

		var buf bytes.Buffer
		return func(ctx context.Context) *graphql.Response {
			buf.Reset()
			data := next()

			if data == nil {
				return nil
			}
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "api/indexer.graphql", Input: `
"""
A 58-character base32 Algorand address. It includes the public key and checksum.
"""
scalar Address

"""
A 64-bit unsigned integer
"""
scalar Uint64

"""
A base64-encoded byte array
"""
scalar Bytes

"""
A JSON map with dynamic elements
"""
scalar Map

"""
An RFC 3339 formatted string representing a time
"""
scalar Time

type Query {
  """
  Lookup block.
  
  Equivalent to GET /v2/blocks/{round-number}
  """
  block(
    """Round number"""
    roundNumber: Uint64!
  ): Block

  """
  Returns 200 if healthy.
  
  Equivalent to GET /health
  """
  healthCheck: HealthCheck

  """
  Lookup account information.
  
  Equivalent to GET /v2/accounts/{account-id}
  """
  account(
    """account string"""
    address: Address!

    """
    Include all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates.
    """
    includeAll: Boolean

    """Include results for the specified round."""
    round: Uint64
  ): AccountResponse

  """
  Lookup account transactions.
  
  Equivalent to GET /v2/accounts/{account-id}/transactions
  """
  accountTransactions(
    """account string"""
    account: Address!

    """
    Include results after the given time.
    """
    afterTime: Time

    """Asset ID"""
    assetId: Uint64

    """
    Include results before the given time.
    """
    beforeTime: Time

    """
    Results should have an amount greater than this value. MicroAlgos are the default currency unless an asset-id is provided, in which case the asset will be used.
    """
    currencyGreaterThan: Uint64

    """
    Results should have an amount less than this value. MicroAlgos are the default currency unless an asset-id is provided, in which case the asset will be used.
    """
    currencyLessThan: Uint64

    """Maximum number of results to return."""
    limit: Uint64

    """Include results at or before the specified max-round."""
    maxRound: Uint64

    """Include results at or after the specified min-round."""
    minRound: Uint64

    """
    The next page of results. Use the next token provided by the previous results.
    """
    next: String

    """Specifies a prefix which must be contained in the note field."""
    notePrefix: Bytes

    """Include results which include the rekey-to field."""
    rekeyTo: Boolean

    """Include results for the specified round."""
    round: Uint64

    """
    SigType filters just results using the specified type of signature:
    * sig - Standard
    * msig - MultiSig
    * lsig - LogicSig
    """
    sigType: SigType
    txType: TxType

    """Lookup the specific transaction by ID."""
    id: String
  ): TransactionsResponse

  """
  Search for accounts.
  
  Equivalent to GET /v2/accounts
  """
  accounts(
    """Application ID"""
    applicationId: Uint64

    """Asset ID"""
    assetId: Uint64

    """Include accounts configured to use this spending key."""
    authAddr: Address

    """
    Results should have an amount greater than this value. MicroAlgos are the default currency unless an asset-id is provided, in which case the asset will be used.
    """
    currencyGreaterThan: Uint64

    """
    Results should have an amount less than this value. MicroAlgos are the default currency unless an asset-id is provided, in which case the asset will be used.
    """
    currencyLessThan: Uint64

    """
    Include all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates.
    """
    includeAll: Boolean

    """Maximum number of results to return."""
    limit: Uint64

    """
    The next page of results. Use the next token provided by the previous results.
    """
    next: String

    """
    Include results for the specified round. For performance reasons, this parameter may be disabled on some configurations.
    """
    round: Uint64
  ): AccountsResponse

  """
  Lookup application.
  
  Equivalent to GET /v2/applications/{application-id}
  """
  application(
    id: Uint64!

    """
    Include all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates.
    """
    includeAll: Boolean
  ): ApplicationResponse

  """
  Search for applications
  
  Equivalent to GET /v2/applications
  """
  applications(
    """Application ID"""
    id: Uint64

    """
    Include all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates.
    """
    includeAll: Boolean

    """Maximum number of results to return."""
    limit: Uint64

    """
    The next page of results. Use the next token provided by the previous results.
    """
    next: String
  ): ApplicationsResponse

  """
  Lookup asset information.
  
  Equivalent to GET /v2/assets/{asset-id}
  """
  asset(
    id: Uint64!

    """
    Include all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates.
    """
    includeAll: Boolean
  ): AssetResponse

  """
  Lookup the list of accounts who hold this asset 
  
  Equivalent to GET /v2/assets/{asset-id}/balances
  """
  assetBalances(
    assetId: Uint64!

    """
    Results should have an amount greater than this value. MicroAlgos are the default currency unless an asset-id is provided, in which case the asset will be used.
    """
    currencyGreaterThan: Uint64

    """
    Results should have an amount less than this value. MicroAlgos are the default currency unless an asset-id is provided, in which case the asset will be used.
    """
    currencyLessThan: Uint64

    """
    Include all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates.
    """
    includeAll: Boolean

    """Maximum number of results to return."""
    limit: Uint64

    """
    The next page of results. Use the next token provided by the previous results.
    """
    next: String

    """Include results for the specified round."""
    round: Uint64
  ): AssetBalancesResponse

  """
  Lookup transactions for an asset.
  
  Equivalent to GET /v2/assets/{asset-id}/transactions
  """
  assetTransactions(
    """
    Only include transactions with this address in one of the transaction fields.
    """
    address: Address

    """
    Combine with the address parameter to define what type of address to search for.
    """
    addressRole: AddressRole

    """
    Include results after the given time.
    """
    afterTime: Time
    assetId: Uint64!

    """
    Include results before the given time.
    """
    beforeTime: Time

    """
    Results should have an amount greater than this value. MicroAlgos are the default currency unless an asset-id is provided, in which case the asset will be used.
    """
    currencyGreaterThan: Uint64

    """
    Results should have an amount less than this value. MicroAlgos are the default currency unless an asset-id is provided, in which case the asset will be used.
    """
    currencyLessThan: Uint64

    """
    Combine with address and address-role parameters to define what type of address to search for. The close to fields are normally treated as a receiver, if you would like to exclude them set this parameter to true.
    """
    excludeCloseTo: Boolean

    """Maximum number of results to return."""
    limit: Uint64

    """Include results at or before the specified max-round."""
    maxRound: Uint64

    """Include results at or after the specified min-round."""
    minRound: Uint64

    """
    The next page of results. Use the next token provided by the previous results.
    """
    next: String

    """Specifies a prefix which must be contained in the note field."""
    notePrefix: Bytes

    """Include results which include the rekey-to field."""
    rekeyTo: Boolean

    """Include results for the specified round."""
    round: Uint64

    """
    SigType filters just results using the specified type of signature:
    * sig - Standard
    * msig - MultiSig
    * lsig - LogicSig
    """
    sigType: SigType
    txType: TxType

    """Lookup the specific transaction by ID."""
    id: String
  ): TransactionsResponse

  """
  Search for assets.
  
  Equivalent to GET /v2/assets
  """
  assets(
    """Asset ID"""
    id: Uint64

    """Filter just assets with the given creator address."""
    creator: Address

    """
    Include all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates.
    """
    includeAll: Boolean

    """Maximum number of results to return."""
    limit: Uint64

    """Filter just assets with the given name."""
    name: String

    """
    The next page of results. Use the next token provided by the previous results.
    """
    next: String

    """Filter just assets with the given unit."""
    unit: String
  ): AssetsResponse

  """
  Lookup a single transaction.
  
  Equivalent to GET /v2/transactions/{txid}
  """
  transaction(id: String!): TransactionResponse

  """
  Search for transactions.
  
  Equivalent to GET /v2/transactions
  """
  transactions(
    """
    Only include transactions with this address in one of the transaction fields.
    """
    address: Address

    """
    Combine with the address parameter to define what type of address to search for.
    """
    addressRole: AddressRole

    """
    Include results after the given time.
    """
    afterTime: Time

    """Application ID"""
    applicationId: Uint64

    """Asset ID"""
    assetId: Uint64

    """
    Include results before the given time.
    """
    beforeTime: Time

    """
    Results should have an amount greater than this value. MicroAlgos are the default currency unless an asset-id is provided, in which case the asset will be used.
    """
    currencyGreaterThan: Uint64

    """
    Results should have an amount less than this value. MicroAlgos are the default currency unless an asset-id is provided, in which case the asset will be used.
    """
    currencyLessThan: Uint64

    """
    Combine with address and address-role parameters to define what type of address to search for. The close to fields are normally treated as a receiver, if you would like to exclude them set this parameter to true.
    """
    excludeCloseTo: Boolean

    """Maximum number of results to return."""
    limit: Uint64

    """Include results at or before the specified max-round."""
    maxRound: Uint64

    """Include results at or after the specified min-round."""
    minRound: Uint64

    """
    The next page of results. Use the next token provided by the previous results.
    """
    next: String

    """Specifies a prefix which must be contained in the note field."""
    notePrefix: Bytes

    """Include results which include the rekey-to field."""
    rekeyTo: Boolean

    """Include results for the specified round."""
    round: Uint64

    """
    SigType filters just results using the specified type of signature:
    * sig - Standard
    * msig - MultiSig
    * lsig - LogicSig
    """
    sigType: SigType
    txType: TxType

    """Lookup the specific transaction by ID."""
    id: String
  ): TransactionsResponse
}

type Subscription {
  """
  This subscription will trigger on every new block.
  """
  newBlock: Block

  """
  This subscription will trigger when a new block contains transactions which reference the given account.
  """
  accountUpdate(address: Address!): AccountUpdateResponse
}

type AccountUpdateResponse {
  """The account that was updated."""
  account: Account!

  """The transactions that caused the update."""
  transactions: [Transaction!]!
}

"""
Block information.

Definition:
data/bookkeeping/block.go : Block
"""
type Block {
  """\[gh\] hash to which this block belongs."""
  genesisHash: Bytes!

  """\[gen\] ID to which this block belongs."""
  genesisId: String!

  """\[prev\] Previous block hash."""
  previousBlockHash: Bytes!

  """Fields relating to rewards,"""
  rewards: BlockRewards

  """\[rnd\] Current round on which this block was appended to the chain."""
  round: Uint64!

  """\[seed\] Sortition seed."""
  seed: Bytes!

  """\[ts\] Block creation timestamp in seconds since eposh"""
  timestamp: Uint64!

  """\[txns\] list of transactions corresponding to a given round."""
  transactions: [Transaction!]!

  """
  \[txn\] TransactionsRoot authenticates the set of transactions appearing in the block. More specifically, it's the root of a merkle tree whose leaves are the block's Txids, in lexicographic order. For the empty block, it's 0. Note that the TxnRoot does not authenticate the signatures on the transactions, only the transactions themselves. Two blocks with the same transactions but in a different order and with different signatures will have the same TxnRoot.
  """
  transactionsRoot: Bytes!

  """
  \[tc\] TxnCounter counts the number of transactions committed in the ledger, from the time at which support for this feature was introduced.
  
  Specifically, TxnCounter is the number of the next transaction that will be committed after this block.  It is 0 when no transactions have ever been committed (since TxnCounter started being supported).
  """
  txnCounter: Uint64

  """Fields relating to a protocol upgrade."""
  upgradeState: BlockUpgradeState

  """Fields relating to voting for a protocol upgrade."""
  upgradeVote: BlockUpgradeVote
}

"""Fields relating to rewards,"""
type BlockRewards {
  """
  \[fees\] accepts transaction fees, it can only spend to the incentive pool.
  """
  feeSink: Address!

  """
  \[rwcalr\] number of leftover MicroAlgos after the distribution of rewards-rate MicroAlgos for every reward unit in the next round.
  """
  rewardsCalculationRound: Uint64!

  """
  \[earn\] How many rewards, in MicroAlgos, have been distributed to each RewardUnit of MicroAlgos since genesis.
  """
  rewardsLevel: Uint64!

  """
  \[rwd\] accepts periodic injections from the fee-sink and continually redistributes them as rewards.
  """
  rewardsPool: Address!

  """
  \[rate\] Number of new MicroAlgos added to the participation stake from rewards at the next round.
  """
  rewardsRate: Uint64!

  """
  \[frac\] Number of leftover MicroAlgos after the distribution of RewardsRate/rewardUnits MicroAlgos for every reward unit in the next round.
  """
  rewardsResidue: Uint64!
}

"""
Contains all fields common to all transactions and serves as an envelope to all transactions type.

Definition:
data/transactions/signedtxn.go : SignedTxn
data/transactions/transaction.go : Transaction

"""
type Transaction {
  """
  Fields for application transactions.
  
  Definition:
  data/transactions/application.go : ApplicationCallTxnFields
  """
  applicationTransaction: TransactionApplication

  """
  Fields for asset allocation, re-configuration, and destruction.
  
  
  A zero value for asset-id indicates asset creation.
  A zero value for the params indicates asset destruction.
  
  Definition:
  data/transactions/asset.go : AssetConfigTxnFields
  """
  assetConfigTransaction: TransactionAssetConfig

  """
  Fields for an asset freeze transaction.
  
  Definition:
  data/transactions/asset.go : AssetFreezeTxnFields
  """
  assetFreezeTransaction: TransactionAssetFreeze

  """
  Fields for an asset transfer transaction.
  
  Definition:
  data/transactions/asset.go : AssetTransferTxnFields
  """
  assetTransferTransaction: TransactionAssetTransfer

  """
  \[sgnr\] this is included with signed transactions when the signing address does not equal the sender. The backend can use this to ensure that auth addr is equal to the accounts auth addr.
  """
  authAddr: Address

  """\[rc\] rewards applied to close-remainder-to account."""
  closeRewards: Uint64

  """\[ca\] closing amount for transaction."""
  closingAmount: Uint64

  """Round when the transaction was confirmed."""
  confirmedRound: Uint64

  """
  Specifies an application index (ID) if an application was created with this transaction.
  """
  createdApplicationId: Uint64

  """
  Specifies an asset index (ID) if an asset was created with this transaction.
  """
  createdAssetId: Uint64

  """\[fee\] Transaction fee."""
  fee: Uint64!

  """\[fv\] First valid round for this transaction."""
  firstValid: Uint64!

  """\[gh\] Hash of genesis block."""
  genesisHash: Bytes

  """\[gen\] genesis block ID."""
  genesisId: String

  """Application state delta."""
  globalStateDelta: [EvalDeltaKeyValue!]

  """
  \[grp\] Base64 encoded byte array of a sha512/256 digest. When present indicates that this transaction is part of a transaction group and the value is the sha512/256 hash of the transactions in that group.
  """
  group: Bytes

  """Transaction ID"""
  id: String!

  """Offset into the round where this transaction was confirmed."""
  intraRoundOffset: Uint64

  """
  Fields for a keyreg transaction.
  
  Definition:
  data/transactions/keyreg.go : KeyregTxnFields
  """
  keyregTransaction: TransactionKeyreg

  """\[lv\] Last valid round for this transaction."""
  lastValid: Uint64!

  """
  \[lx\] Base64 encoded 32-byte array. Lease enforces mutual exclusion of transactions.  If this field is nonzero, then once the transaction is confirmed, it acquires the lease identified by the (Sender, Lease) pair of the transaction until the LastValid round passes.  While this transaction possesses the lease, no other transaction specifying this lease can be confirmed.
  """
  lease: Bytes

  """
  \[ld\] Local state key/value changes for the application being executed by this transaction.
  """
  localStateDelta: [AccountStateDelta!]

  """\[note\] Free form data."""
  note: Bytes

  """
  Fields for a payment transaction.
  
  Definition:
  data/transactions/payment.go : PaymentTxnFields
  """
  paymentTransaction: TransactionPayment

  """\[rr\] rewards applied to receiver account."""
  receiverRewards: Uint64

  """
  \[rekey\] when included in a valid transaction, the accounts auth addr will be updated with this value and future signatures must be signed with the key represented by this address.
  """
  rekeyTo: Address

  """Time when the block this transaction is in was confirmed."""
  roundTime: Uint64

  """\[snd\] Sender's address."""
  sender: Address!

  """\[rs\] rewards applied to sender account."""
  senderRewards: Uint64

  """
  Validation signature associated with some data. Only one of the signatures should be provided.
  """
  signature: TransactionSignature!

  """
  \[type\] Indicates what type of transaction this is. Different types have different fields.
  
  Valid types, and where their fields are stored:
  * \[pay\] payment-transaction
  * \[keyreg\] keyreg-transaction
  * \[acfg\] asset-config-transaction
  * \[axfer\] asset-transfer-transaction
  * \[afrz\] asset-freeze-transaction
  * \[appl\] application-transaction
  """
  txType: TxType!
}

"""
Fields for application transactions.

Definition:
data/transactions/application.go : ApplicationCallTxnFields
"""
type TransactionApplication {
  """
  \[apat\] List of accounts in addition to the sender that may be accessed from the application's approval-program and clear-state-program.
  """
  accounts: [Address!]!

  """
  \[apaa\] transaction specific arguments accessed from the application's approval-program and clear-state-program.
  """
  applicationArgs: [Bytes!]!

  """\[apid\] ID of the application being configured or empty if creating."""
  applicationId: Uint64!

  """
  \[apap\] Logic executed for every application transaction, except when on-completion is set to "clear". It can read and write global state for the application, as well as account-specific local state. Approval programs may reject the transaction.
  """
  approvalProgram: Bytes

  """
  \[apsu\] Logic executed for application transactions with on-completion set to "clear". It can read and write global state for the application, as well as account-specific local state. Clear state programs cannot reject the transaction.
  """
  clearStateProgram: Bytes

  """\[epp\] specifies the additional app program len requested in pages."""
  extraProgramPages: Uint64

  """
  \[apfa\] Lists the applications in addition to the application-id whose global states may be accessed by this application's approval-program and clear-state-program. The access is read-only.
  """
  foreignApps: [Uint64!]!

  """
  \[apas\] lists the assets whose parameters may be accessed by this application's ApprovalProgram and ClearStateProgram. The access is read-only.
  """
  foreignAssets: [Uint64!]!

  """
  Represents a \[apls\] local-state or \[apgs\] global-state schema. These schemas determine how much storage may be used in a local-state or global-state for an application. The more space used, the larger minimum balance must be maintained in the account holding the data.
  """
  globalStateSchema: StateSchema

  """
  Represents a \[apls\] local-state or \[apgs\] global-state schema. These schemas determine how much storage may be used in a local-state or global-state for an application. The more space used, the larger minimum balance must be maintained in the account holding the data.
  """
  localStateSchema: StateSchema

  """
  \[apan\] defines the what additional actions occur with the transaction.
  
  Valid types:
  * noop
  * optin
  * closeout
  * clear
  * update
  * update
  * delete
  """
  onCompletion: OnCompletion!
}

"""
Represents a \[apls\] local-state or \[apgs\] global-state schema. These schemas determine how much storage may be used in a local-state or global-state for an application. The more space used, the larger minimum balance must be maintained in the account holding the data.
"""
type StateSchema {
  """
  Maximum number of TEAL byte slices that may be stored in the key/value store.
  """
  numByteSlice: Uint64!

  """
  Maximum number of TEAL uints that may be stored in the key/value store.
  """
  numUint: Uint64!
}

enum OnCompletion {
  NOOP
  OPTIN
  CLOSEOUT
  CLEAR
  UPDATE
  DELETE
}

"""
Fields for asset allocation, re-configuration, and destruction.


A zero value for asset-id indicates asset creation.
A zero value for the params indicates asset destruction.

Definition:
data/transactions/asset.go : AssetConfigTxnFields
"""
type TransactionAssetConfig {
  """\[xaid\] ID of the asset being configured or empty if creating."""
  assetId: Uint64

  """
  AssetParams specifies the parameters for an asset.
  
  \[apar\] when part of an AssetConfig transaction.
  
  Definition:
  data/transactions/asset.go : AssetParams
  """
  params: AssetParams
}

"""
AssetParams specifies the parameters for an asset.

\[apar\] when part of an AssetConfig transaction.

Definition:
data/transactions/asset.go : AssetParams
"""
type AssetParams {
  """
  \[c\] Address of account used to clawback holdings of this asset.  If empty, clawback is not permitted.
  """
  clawback: Address

  clawbackAccount: Account

  """
  The address that created this asset. This is the address where the parameters for this asset can be found, and also the address where unwanted asset units can be sent in the worst case.
  """
  creator: Address!

  creatorAccount: Account!

  """
  \[dc\] The number of digits to use after the decimal point when displaying this asset. If 0, the asset is not divisible. If 1, the base unit of the asset is in tenths. If 2, the base unit of the asset is in hundredths, and so on. This value must be between 0 and 19 (inclusive).
  """
  decimals: Uint64!

  """\[df\] Whether holdings of this asset are frozen by default."""
  defaultFrozen: Boolean!

  """
  \[f\] Address of account used to freeze holdings of this asset.  If empty, freezing is not permitted.
  """
  freeze: Address

  freezeAccount: Account

  """
  \[m\] Address of account used to manage the keys of this asset and to destroy it.
  """
  manager: Address

  managerAccount: Account

  """
  \[am\] A commitment to some unspecified asset metadata. The format of this metadata is up to the application.
  """
  metadataHash: Bytes

  """\[an\] Name of this asset, as supplied by the creator."""
  name: String

  """
  \[r\] Address of account holding reserve (non-minted) units of this asset.
  """
  reserve: Address

  reserveAccount: Account

  """\[t\] The total number of units of this asset."""
  total: Uint64!

  """\[un\] Name of a unit of this asset, as supplied by the creator."""
  unitName: String

  """\[au\] URL where more information about the asset can be retrieved."""
  url: String
}

"""
Fields for an asset freeze transaction.

Definition:
data/transactions/asset.go : AssetFreezeTxnFields
"""
type TransactionAssetFreeze {
  """\[fadd\] Address of the account whose asset is being frozen or thawed."""
  address: Address!

  """\[faid\] ID of the asset being frozen or thawed."""
  assetId: Uint64!

  """\[afrz\] The new freeze status."""
  newFreezeStatus: Boolean!
}

"""
Fields for an asset transfer transaction.

Definition:
data/transactions/asset.go : AssetTransferTxnFields
"""
type TransactionAssetTransfer {
  """
  \[aamt\] Amount of asset to transfer. A zero amount transferred to self allocates that asset in the account's Assets map.
  """
  amount: Uint64!

  """\[xaid\] ID of the asset being transferred."""
  assetId: Uint64!

  """
  Number of assets transfered to the close-to account as part of the transaction.
  """
  closeAmount: Uint64

  """
  \[aclose\] Indicates that the asset should be removed from the account's Assets map, and specifies where the remaining asset holdings should be transferred.  It's always valid to transfer remaining asset holdings to the creator account.
  """
  closeTo: Address

  """\[arcv\] Recipient address of the transfer."""
  receiver: Address!

  """
  \[asnd\] The effective sender during a clawback transactions. If this is not a zero value, the real transaction sender must be the Clawback address from the AssetParams.
  """
  sender: Address
}

"""Key-value pairs for StateDelta."""
type EvalDeltaKeyValue {
  key: Bytes!

  """Represents a TEAL value delta."""
  value: EvalDelta!
}

"""Represents a TEAL value delta."""
type EvalDelta {
  """\[at\] delta action."""
  action: DeltaAction!

  """\[bs\] bytes value."""
  bytes: Bytes

  """\[ui\] uint value."""
  uint: Uint64
}

enum DeltaAction {
  SET_BYTES
  SET_UINT
  DELETE
}

"""
Fields for a keyreg transaction.

Definition:
data/transactions/keyreg.go : KeyregTxnFields
"""
type TransactionKeyreg {
  """\[nonpart\] Mark the account as participating or non-participating."""
  nonParticipation: Boolean!

  """
  \[selkey\] Public key used with the Verified Random Function (VRF) result during committee selection.
  """
  selectionParticipationKey: Bytes

  """\[votefst\] First round this participation key is valid."""
  voteFirstValid: Uint64

  """\[votekd\] Number of subkeys in each batch of participation keys."""
  voteKeyDilution: Uint64

  """\[votelst\] Last round this participation key is valid."""
  voteLastValid: Uint64

  """
  \[votekey\] Participation public key used in key registration transactions.
  """
  voteParticipationKey: Bytes
}

"""Application state delta."""
type AccountStateDelta {
  address: Address!

  """Application state delta."""
  delta: [EvalDeltaKeyValue!]!
}

"""
Fields for a payment transaction.

Definition:
data/transactions/payment.go : PaymentTxnFields
"""
type TransactionPayment {
  """\[amt\] number of MicroAlgos intended to be transferred."""
  amount: Uint64!

  """
  Number of MicroAlgos that were sent to the close-remainder-to address when closing the sender account.
  """
  closeAmount: Uint64

  """
  \[close\] when set, indicates that the sending account should be closed and all remaining funds be transferred to this address.
  """
  closeRemainderTo: Address

  """\[rcv\] receiver's address."""
  receiver: Address!
}

"""
Validation signature associated with some data. Only one of the signatures should be provided.
"""
type TransactionSignature {
  """
  \[lsig\] Programatic transaction signature.
  
  Definition:
  data/transactions/logicsig.go
  """
  logicsig: TransactionSignatureLogicsig

  """
  \[msig\] structure holding multiple subsignatures.
  
  Definition:
  crypto/multisig.go : MultisigSig
  """
  multisig: TransactionSignatureMultisig

  """\[sig\] Standard ed25519 signature."""
  sig: Bytes
}

"""
\[lsig\] Programatic transaction signature.

Definition:
data/transactions/logicsig.go
"""
type TransactionSignatureLogicsig {
  """\[arg\] Logic arguments, base64 encoded."""
  args: [Bytes!]!

  """
  \[l\] Program signed by a signature or multi signature, or hashed to be the address of ana ccount. Base64 encoded TEAL program.
  """
  logic: Bytes!

  """
  \[msig\] structure holding multiple subsignatures.
  
  Definition:
  crypto/multisig.go : MultisigSig
  """
  multisigSignature: TransactionSignatureMultisig

  """\[sig\] ed25519 signature."""
  signature: Bytes
}

"""
\[msig\] structure holding multiple subsignatures.

Definition:
crypto/multisig.go : MultisigSig
"""
type TransactionSignatureMultisig {
  """\[subsig\] holds pairs of public key and signatures."""
  subsignature: [TransactionSignatureMultisigSubsignature!]

  """\[thr\]"""
  threshold: Uint64

  """\[v\]"""
  version: Uint64
}

type TransactionSignatureMultisigSubsignature {
  """\[pk\]"""
  publicKey: Bytes

  """\[s\]"""
  signature: Bytes
}

enum TxType {
  PAY
  KEYREG
  ACFG
  AXFER
  AFRZ
  APPL
}

"""Fields relating to a protocol upgrade."""
type BlockUpgradeState {
  """\[proto\] The current protocol version."""
  currentProtocol: String!

  """\[nextproto\] The next proposed protocol version."""
  nextProtocol: String

  """\[nextyes\] Number of blocks which approved the protocol upgrade."""
  nextProtocolApprovals: Uint64

  """\[nextswitch\] Round on which the protocol upgrade will take effect."""
  nextProtocolSwitchOn: Uint64

  """
  \[nextbefore\] Deadline round for this protocol upgrade (No votes will be consider after this round).
  """
  nextProtocolVoteBefore: Uint64
}

"""Fields relating to voting for a protocol upgrade."""
type BlockUpgradeVote {
  """\[upgradeyes\] Indicates a yes vote for the current proposal."""
  upgradeApprove: Boolean

  """\[upgradedelay\] Indicates the time between acceptance and execution."""
  upgradeDelay: Uint64

  """\[upgradeprop\] Indicates a proposed upgrade."""
  upgradePropose: String
}

"""A health check response."""
type HealthCheck {
  data: Map
  dbAvailable: Boolean!
  errors: [String!]!
  isMigrating: Boolean!
  message: String!
  round: Uint64!
}

type AccountResponse {
  """
  Account information at a given round.
  
  Definition:
  data/basics/userBalance.go : AccountData
  
  """
  account: Account!

  """Round at which the results were computed."""
  currentRound: Uint64!
}

"""
Account information at a given round.

Definition:
data/basics/userBalance.go : AccountData

"""
type Account {
  """the account public key"""
  address: Address!

  """\[algo\] total number of MicroAlgos in the account"""
  amount: Uint64!

  """
  specifies the amount of MicroAlgos in the account, without the pending rewards.
  """
  amountWithoutPendingRewards: Uint64!

  """
  \[appl\] applications local data stored in this account.
  
  Note the raw object uses ` + "`" + `map[int] -> AppLocalState` + "`" + ` for this type.
  """
  appsLocalState: [ApplicationLocalState!]!

  """
  Get local state for a single application.
  """
  appLocalState(id: Uint64!): ApplicationLocalState

  """
  \[teap\] the sum of all extra application program pages for this account.
  """
  appsTotalExtraPages: Uint64!

  """Specifies maximums on the number of each type that may be stored."""
  appsTotalSchema: ApplicationStateSchema!

  """
  \[asset\] assets held by this account.
  
  Note the raw object uses ` + "`" + `map[int] -> AssetHolding` + "`" + ` for this type.
  """
  assets: [AssetHolding!]!

  """
  Get a single AssetHolding by ID.
  """
  asset(id: Uint64!): AssetHolding

  """
  \[spend\] the address against which signing should be checked. If empty, the address of the current account is used. This field can be updated in any transaction by setting the RekeyTo field.
  """
  authAddr: Address

  """
  The account behind the authAddr, if any.
  """
  authAccount: Account

  """Round during which this account was most recently closed."""
  closedAtRound: Uint64

  """
  \[appp\] parameters of applications created by this account including app global data.
  
  Note: the raw account uses ` + "`" + `map[int] -> AppParams` + "`" + ` for this type.
  """
  createdApps: [Application!]!

  """
  Get a single created app by ID.
  """
  createdApp(id: Uint64!): Application

  """
  \[apar\] parameters of assets created by this account.
  
  Note: the raw account uses ` + "`" + `map[int] -> Asset` + "`" + ` for this type.
  """
  createdAssets: [Asset!]!

  """
  Get a single created asset by ID.
  """
  createdAsset(id: Uint64!): Asset

  """Round during which this account first appeared in a transaction."""
  createdAtRound: Uint64

  """Whether or not this account is currently closed."""
  deleted: Boolean!

  """
  AccountParticipation describes the parameters used by this account in consensus protocol.
  """
  participation: AccountParticipation

  """amount of MicroAlgos of pending rewards in this account."""
  pendingRewards: Uint64!

  """
  \[ebase\] used as part of the rewards computation. Only applicable to accounts which are participating.
  """
  rewardBase: Uint64

  """
  \[ern\] total rewards of MicroAlgos the account has received, including pending rewards.
  """
  rewards: Uint64!

  """The round for which this information is relevant."""
  round: Uint64!

  """
  Indicates what type of signature is used by this account, must be one of:
  * sig
  * msig
  * lsig
  """
  sigType: SigType

  """
  \[onl\] delegation status of the account's MicroAlgos.
  """
  status: AccountStatus!
}

enum AccountStatus {
  """Offline - indicates that the associated account is delegated."""
  OFFLINE
  """Online  - indicates that the associated account used as part of the delegation pool."""
  ONLINE
  """NotParticipating - indicates that the associated account is neither a delegator nor a delegate."""
  NOT_PARTICIPATING
}

"""Stores local state associated with an application."""
type ApplicationLocalState {
  """Round when account closed out of the application."""
  closedOutAtRound: Uint64

  """
  Whether or not the application local state is currently deleted from its account.
  """
  deleted: Boolean!

  """The ID of the application which this local state is for."""
  id: Uint64!

  """The application which this local state is for."""
  application: Application!

  """Represents a key-value store for use in an application."""
  keyValue: [TealKeyValue!]

  """Round when the account opted into the application."""
  optedInAtRound: Uint64

  """Specifies maximums on the number of each type that may be stored."""
  schema: ApplicationStateSchema!
}

"""Represents a key-value pair in an application store."""
type TealKeyValue {
  key: Bytes!

  """Represents a TEAL value."""
  value: TealValue!
}

"""Represents a TEAL value."""
type TealValue {
  """\[tb\] bytes value."""
  bytes: Bytes!

  """\[tt\] value type."""
  type: Uint64!

  """\[ui\] uint value."""
  uint: Uint64!
}

"""Specifies maximums on the number of each type that may be stored."""
type ApplicationStateSchema {
  """\[nbs\] num of byte slices."""
  numByteSlice: Uint64!

  """\[nui\] num of uints."""
  numUint: Uint64!
}

"""
Describes an asset held by an account.

Definition:
data/basics/userBalance.go : AssetHolding
"""
type AssetHolding {
  """\[a\] number of units held."""
  amount: Uint64!

  """Asset ID of the holding."""
  id: Uint64!

  """Asset definition for this holding."""
  asset: Asset!

  """
  Address that created this asset. This is the address where the parameters for this asset can be found, and also the address where unwanted asset units can be sent in the worst case.
  """
  creator: Address!

  """
  Whether or not the asset holding is currently deleted from its account.
  """
  deleted: Boolean!

  """\[f\] whether or not the holding is frozen."""
  frozen: Boolean!

  """Round during which the account opted into this asset holding."""
  optedInAtRound: Uint64

  """Round during which the account opted out of this asset holding."""
  optedOutAtRound: Uint64
}

"""Application index and its parameters"""
type Application {
  """Round when this application was created."""
  createdAtRound: Uint64

  """Whether or not this application is currently deleted."""
  deleted: Boolean!

  """Round when this application was deleted."""
  deletedAtRound: Uint64

  """\[appidx\] application index."""
  id: Uint64!

  """Stores the global information associated with an application."""
  params: ApplicationParams!
}

"""Stores the global information associated with an application."""
type ApplicationParams {
  """\[approv\] approval program."""
  approvalProgram: Bytes!

  """\[clearp\] approval program."""
  clearStateProgram: Bytes!

  """
  The address that created this application. This is the address where the parameters and global state for this application can be found.
  """
  creator: Address!

  creatorAccount: Account!

  """\[epp\] the amount of extra program pages available to this app."""
  extraProgramPages: Uint64!

  """Represents a key-value store for use in an application."""
  globalState: [TealKeyValue!]!

  """Specifies maximums on the number of each type that may be stored."""
  globalStateSchema: ApplicationStateSchema!

  """Specifies maximums on the number of each type that may be stored."""
  localStateSchema: ApplicationStateSchema!
}

"""Specifies both the unique identifier and the parameters for an asset"""
type Asset {
  """Round during which this asset was created."""
  createdAtRound: Uint64

  """Whether or not this asset is currently deleted."""
  deleted: Boolean!

  """Round during which this asset was destroyed."""
  destroyedAtRound: Uint64

  """unique asset identifier"""
  id: Uint64!

  """
  AssetParams specifies the parameters for an asset.
  
  \[apar\] when part of an AssetConfig transaction.
  
  Definition:
  data/transactions/asset.go : AssetParams
  """
  params: AssetParams!
}

"""
AccountParticipation describes the parameters used by this account in consensus protocol.
"""
type AccountParticipation {
  """
  \[sel\] Selection public key (if any) currently registered for this round.
  """
  selectionParticipationKey: Bytes!

  """\[voteFst\] First round for which this participation is valid."""
  voteFirstValid: Uint64!

  """\[voteKD\] Number of subkeys in each batch of participation keys."""
  voteKeyDilution: Uint64!

  """\[voteLst\] Last round for which this participation is valid."""
  voteLastValid: Uint64!

  """
  \[vote\] root participation public key (if any) currently registered for this round.
  """
  voteParticipationKey: Bytes!
}

enum SigType {
  SIG
  MSIG
  LSIG
}

type AccountsResponse {
  accounts: [Account!]!

  """Round at which the results were computed."""
  currentRound: Uint64!

  """
  Used for pagination, when making another request provide this token with the next parameter.
  """
  nextToken: String
}

type ApplicationResponse {
  """Application index and its parameters"""
  application: Application

  """Round at which the results were computed."""
  currentRound: Uint64!
}

type ApplicationsResponse {
  applications: [Application!]!

  """Round at which the results were computed."""
  currentRound: Uint64!

  """
  Used for pagination, when making another request provide this token with the next parameter.
  """
  nextToken: String
}

type AssetResponse {
  """Specifies both the unique identifier and the parameters for an asset"""
  asset: Asset!

  """Round at which the results were computed."""
  currentRound: Uint64!
}

type AssetBalancesResponse {
  balances: [MiniAssetHolding!]!

  """Round at which the results were computed."""
  currentRound: Uint64!

  """
  Used for pagination, when making another request provide this token with the next parameter.
  """
  nextToken: String
}

"""A simplified version of AssetHolding """
type MiniAssetHolding {
  address: Address!

  """
  The account this asset holding belongs to.
  """
  account: Account!

  amount: Uint64!

  """
  Whether or not this asset holding is currently deleted from its account.
  """
  deleted: Boolean!
  frozen: Boolean!

  """Round during which the account opted into the asset."""
  optedInAtRound: Uint64

  """Round during which the account opted out of the asset."""
  optedOutAtRound: Uint64
}

enum AddressRole {
  SENDER
  RECEIVER
  FREEZE_TARGET
}

type AssetsResponse {
  assets: [Asset!]!

  """Round at which the results were computed."""
  currentRound: Uint64!

  """
  Used for pagination, when making another request provide this token with the next parameter.
  """
  nextToken: String
}

type TransactionResponse {
  """Round at which the results were computed."""
  currentRound: Uint64!

  """
  Contains all fields common to all transactions and serves as an envelope to all transactions type.
  
  Definition:
  data/transactions/signedtxn.go : SignedTxn
  data/transactions/transaction.go : Transaction
  
  """
  transaction: Transaction!
}

type TransactionsResponse {
  """Round at which the results were computed."""
  currentRound: Uint64!

  """
  Used for pagination, when making another request provide this token with the next parameter.
  """
  nextToken: String
  transactions: [Transaction!]!
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Account_appLocalState_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 uint64
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNUint642uint64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Account_asset_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 uint64
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNUint642uint64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Account_createdApp_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 uint64
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNUint642uint64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Account_createdAsset_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 uint64
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNUint642uint64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_accountTransactions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["account"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("account"))
		arg0, err = ec.unmarshalNAddress2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["account"] = arg0
	var arg1 *time.Time
	if tmp, ok := rawArgs["afterTime"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("afterTime"))
		arg1, err = ec.unmarshalOTime2timeTime(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["afterTime"] = arg1
	var arg2 *uint64
	if tmp, ok := rawArgs["assetId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("assetId"))
		arg2, err = ec.unmarshalOUint642uint64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["assetId"] = arg2
	var arg3 *time.Time
	if tmp, ok := rawArgs["beforeTime"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("beforeTime"))
		arg3, err = ec.unmarshalOTime2timeTime(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["beforeTime"] = arg3
	var arg4 *uint64
	if tmp, ok := rawArgs["currencyGreaterThan"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("currencyGreaterThan"))
		arg4, err = ec.unmarshalOUint642uint64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["currencyGreaterThan"] = arg4
	var arg5 *uint64
	if tmp, ok := rawArgs["currencyLessThan"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("currencyLessThan"))
		arg5, err = ec.unmarshalOUint642uint64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["currencyLessThan"] = arg5
	var arg6 *uint64
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg6, err = ec.unmarshalOUint642uint64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg6
	var arg7 *uint64
	if tmp, ok := rawArgs["maxRound"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxRound"))
		arg7, err = ec.unmarshalOUint642uint64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["maxRound"] = arg7
	var arg8 *uint64
	if tmp, ok := rawArgs["minRound"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("minRound"))
		arg8, err = ec.unmarshalOUint642uint64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["minRound"] = arg8
	var arg9 *string
	if tmp, ok := rawArgs["next"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("next"))
		arg9, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["next"] = arg9
	var arg10 []byte
	if tmp, ok := rawArgs["notePrefix"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("notePrefix"))
		arg10, err = ec.unmarshalOBytes2byte(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["notePrefix"] = arg10
	var arg11 *bool
	if tmp, ok := rawArgs["rekeyTo"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rekeyTo"))
		arg11, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["rekeyTo"] = arg11
	var arg12 *uint64
	if tmp, ok := rawArgs["round"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("round"))
		arg12, err = ec.unmarshalOUint642uint64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["round"] = arg12
	var arg13 *model.SigType
	if tmp, ok := rawArgs["sigType"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sigType"))
		arg13, err = ec.unmarshalOSigType2githubcomalgorandindexerapigraphmodelSigType(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sigType"] = arg13
	var arg14 *model.TxType
	if tmp, ok := rawArgs["txType"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("txType"))
		arg14, err = ec.unmarshalOTxType2githubcomalgorandindexerapigraphmodelTxType(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["txType"] = arg14
	var arg15 *string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg15, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg15
	return args, nil
}

func (ec *executionContext) field_Query_account_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["address"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("address"))
		arg0, err = ec.unmarshalNAddress2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["address"] = arg0
	var arg1 *bool
	if tmp, ok := rawArgs["includeAll"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeAll"))
		arg1, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeAll"] = arg1
	var arg2 *uint64
	if tmp, ok := rawArgs["round"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("round"))
		arg2, err = ec.unmarshalOUint642uint64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["round"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_accounts_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *uint64
	if tmp, ok := rawArgs["applicationId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("applicationId"))
		arg0, err = ec.unmarshalOUint642uint64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["applicationId"] = arg0
	var arg1 *uint64
	if tmp, ok := rawArgs["assetId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("assetId"))
		arg1, err = ec.unmarshalOUint642uint64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["assetId"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["authAddr"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authAddr"))
		arg2, err = ec.unmarshalOAddress2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["authAddr"] = arg2
	var arg3 *uint64
	if tmp, ok := rawArgs["currencyGreaterThan"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("currencyGreaterThan"))
		arg3, err = ec.unmarshalOUint642uint64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["currencyGreaterThan"] = arg3
	var arg4 *uint64
	if tmp, ok := rawArgs["currencyLessThan"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("currencyLessThan"))
		arg4, err = ec.unmarshalOUint642uint64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["currencyLessThan"] = arg4
	var arg5 *bool
	if tmp, ok := rawArgs["includeAll"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeAll"))
		arg5, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeAll"] = arg5
	var arg6 *uint64
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg6, err = ec.unmarshalOUint642uint64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg6
	var arg7 *string
	if tmp, ok := rawArgs["next"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("next"))
		arg7, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["next"] = arg7
	var arg8 *uint64
	if tmp, ok := rawArgs["round"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("round"))
		arg8, err = ec.unmarshalOUint642uint64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["round"] = arg8
	return args, nil
}

func (ec *executionContext) field_Query_application_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 uint64
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNUint642uint64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 *bool
	if tmp, ok := rawArgs["includeAll"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeAll"))
		arg1, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeAll"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_applications_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *uint64
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalOUint642uint64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 *bool
	if tmp, ok := rawArgs["includeAll"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeAll"))
		arg1, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeAll"] = arg1
	var arg2 *uint64
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg2, err = ec.unmarshalOUint642uint64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["next"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("next"))
		arg3, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["next"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query_assetBalances_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 uint64
	if tmp, ok := rawArgs["assetId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("assetId"))
		arg0, err = ec.unmarshalNUint642uint64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["assetId"] = arg0
	var arg1 *uint64
	if tmp, ok := rawArgs["currencyGreaterThan"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("currencyGreaterThan"))
		arg1, err = ec.unmarshalOUint642uint64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["currencyGreaterThan"] = arg1
	var arg2 *uint64
	if tmp, ok := rawArgs["currencyLessThan"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("currencyLessThan"))
		arg2, err = ec.unmarshalOUint642uint64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["currencyLessThan"] = arg2
	var arg3 *bool
	if tmp, ok := rawArgs["includeAll"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeAll"))
		arg3, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeAll"] = arg3
	var arg4 *uint64
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg4, err = ec.unmarshalOUint642uint64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg4
	var arg5 *string
	if tmp, ok := rawArgs["next"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("next"))
		arg5, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["next"] = arg5
	var arg6 *uint64
	if tmp, ok := rawArgs["round"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("round"))
		arg6, err = ec.unmarshalOUint642uint64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["round"] = arg6
	return args, nil
}

func (ec *executionContext) field_Query_assetTransactions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["address"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("address"))
		arg0, err = ec.unmarshalOAddress2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["address"] = arg0
	var arg1 *model.AddressRole
	if tmp, ok := rawArgs["addressRole"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addressRole"))
		arg1, err = ec.unmarshalOAddressRole2githubcomalgorandindexerapigraphmodelAddressRole(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["addressRole"] = arg1
	var arg2 *time.Time
	if tmp, ok := rawArgs["afterTime"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("afterTime"))
		arg2, err = ec.unmarshalOTime2timeTime(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["afterTime"] = arg2
	var arg3 uint64
	if tmp, ok := rawArgs["assetId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("assetId"))
		arg3, err = ec.unmarshalNUint642uint64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["assetId"] = arg3
	var arg4 *time.Time
	if tmp, ok := rawArgs["beforeTime"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("beforeTime"))
		arg4, err = ec.unmarshalOTime2timeTime(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["beforeTime"] = arg4
	var arg5 *uint64
	if tmp, ok := rawArgs["currencyGreaterThan"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("currencyGreaterThan"))
		arg5, err = ec.unmarshalOUint642uint64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["currencyGreaterThan"] = arg5
	var arg6 *uint64
	if tmp, ok := rawArgs["currencyLessThan"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("currencyLessThan"))
		arg6, err = ec.unmarshalOUint642uint64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["currencyLessThan"] = arg6
	var arg7 *bool
	if tmp, ok := rawArgs["excludeCloseTo"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("excludeCloseTo"))
		arg7, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["excludeCloseTo"] = arg7
	var arg8 *uint64
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg8, err = ec.unmarshalOUint642uint64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg8
	var arg9 *uint64
	if tmp, ok := rawArgs["maxRound"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxRound"))
		arg9, err = ec.unmarshalOUint642uint64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["maxRound"] = arg9
	var arg10 *uint64
	if tmp, ok := rawArgs["minRound"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("minRound"))
		arg10, err = ec.unmarshalOUint642uint64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["minRound"] = arg10
	var arg11 *string
	if tmp, ok := rawArgs["next"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("next"))
		arg11, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["next"] = arg11
	var arg12 []byte
	if tmp, ok := rawArgs["notePrefix"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("notePrefix"))
		arg12, err = ec.unmarshalOBytes2byte(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["notePrefix"] = arg12
	var arg13 *bool
	if tmp, ok := rawArgs["rekeyTo"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rekeyTo"))
		arg13, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["rekeyTo"] = arg13
	var arg14 *uint64
	if tmp, ok := rawArgs["round"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("round"))
		arg14, err = ec.unmarshalOUint642uint64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["round"] = arg14
	var arg15 *model.SigType
	if tmp, ok := rawArgs["sigType"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sigType"))
		arg15, err = ec.unmarshalOSigType2githubcomalgorandindexerapigraphmodelSigType(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sigType"] = arg15
	var arg16 *model.TxType
	if tmp, ok := rawArgs["txType"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("txType"))
		arg16, err = ec.unmarshalOTxType2githubcomalgorandindexerapigraphmodelTxType(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["txType"] = arg16
	var arg17 *string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg17, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg17
	return args, nil
}

func (ec *executionContext) field_Query_asset_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 uint64
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNUint642uint64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 *bool
	if tmp, ok := rawArgs["includeAll"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeAll"))
		arg1, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeAll"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_assets_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *uint64
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalOUint642uint64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["creator"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("creator"))
		arg1, err = ec.unmarshalOAddress2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["creator"] = arg1
	var arg2 *bool
	if tmp, ok := rawArgs["includeAll"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeAll"))
		arg2, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeAll"] = arg2
	var arg3 *uint64
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg3, err = ec.unmarshalOUint642uint64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg4, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg4
	var arg5 *string
	if tmp, ok := rawArgs["next"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("next"))
		arg5, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["next"] = arg5
	var arg6 *string
	if tmp, ok := rawArgs["unit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("unit"))
		arg6, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["unit"] = arg6
	return args, nil
}

func (ec *executionContext) field_Query_block_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 uint64
	if tmp, ok := rawArgs["roundNumber"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("roundNumber"))
		arg0, err = ec.unmarshalNUint642uint64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["roundNumber"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_transaction_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_transactions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["address"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("address"))
		arg0, err = ec.unmarshalOAddress2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["address"] = arg0
	var arg1 *model.AddressRole
	if tmp, ok := rawArgs["addressRole"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addressRole"))
		arg1, err = ec.unmarshalOAddressRole2githubcomalgorandindexerapigraphmodelAddressRole(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["addressRole"] = arg1
	var arg2 *time.Time
	if tmp, ok := rawArgs["afterTime"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("afterTime"))
		arg2, err = ec.unmarshalOTime2timeTime(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["afterTime"] = arg2
	var arg3 *uint64
	if tmp, ok := rawArgs["applicationId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("applicationId"))
		arg3, err = ec.unmarshalOUint642uint64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["applicationId"] = arg3
	var arg4 *uint64
	if tmp, ok := rawArgs["assetId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("assetId"))
		arg4, err = ec.unmarshalOUint642uint64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["assetId"] = arg4
	var arg5 *time.Time
	if tmp, ok := rawArgs["beforeTime"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("beforeTime"))
		arg5, err = ec.unmarshalOTime2timeTime(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["beforeTime"] = arg5
	var arg6 *uint64
	if tmp, ok := rawArgs["currencyGreaterThan"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("currencyGreaterThan"))
		arg6, err = ec.unmarshalOUint642uint64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["currencyGreaterThan"] = arg6
	var arg7 *uint64
	if tmp, ok := rawArgs["currencyLessThan"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("currencyLessThan"))
		arg7, err = ec.unmarshalOUint642uint64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["currencyLessThan"] = arg7
	var arg8 *bool
	if tmp, ok := rawArgs["excludeCloseTo"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("excludeCloseTo"))
		arg8, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["excludeCloseTo"] = arg8
	var arg9 *uint64
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg9, err = ec.unmarshalOUint642uint64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg9
	var arg10 *uint64
	if tmp, ok := rawArgs["maxRound"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxRound"))
		arg10, err = ec.unmarshalOUint642uint64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["maxRound"] = arg10
	var arg11 *uint64
	if tmp, ok := rawArgs["minRound"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("minRound"))
		arg11, err = ec.unmarshalOUint642uint64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["minRound"] = arg11
	var arg12 *string
	if tmp, ok := rawArgs["next"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("next"))
		arg12, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["next"] = arg12
	var arg13 []byte
	if tmp, ok := rawArgs["notePrefix"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("notePrefix"))
		arg13, err = ec.unmarshalOBytes2byte(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["notePrefix"] = arg13
	var arg14 *bool
	if tmp, ok := rawArgs["rekeyTo"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rekeyTo"))
		arg14, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["rekeyTo"] = arg14
	var arg15 *uint64
	if tmp, ok := rawArgs["round"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("round"))
		arg15, err = ec.unmarshalOUint642uint64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["round"] = arg15
	var arg16 *model.SigType
	if tmp, ok := rawArgs["sigType"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sigType"))
		arg16, err = ec.unmarshalOSigType2githubcomalgorandindexerapigraphmodelSigType(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sigType"] = arg16
	var arg17 *model.TxType
	if tmp, ok := rawArgs["txType"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("txType"))
		arg17, err = ec.unmarshalOTxType2githubcomalgorandindexerapigraphmodelTxType(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["txType"] = arg17
	var arg18 *string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg18, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg18
	return args, nil
}

func (ec *executionContext) field_Subscription_accountUpdate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["address"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("address"))
		arg0, err = ec.unmarshalNAddress2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["address"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _Account_address(ctx context.Context, field graphql.CollectedField, obj *model.Account) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Address, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNAddress2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Account_amount(ctx context.Context, field graphql.CollectedField, obj *model.Account) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Amount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _Account_amountWithoutPendingRewards(ctx context.Context, field graphql.CollectedField, obj *model.Account) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AmountWithoutPendingRewards, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _Account_appsLocalState(ctx context.Context, field graphql.CollectedField, obj *model.Account) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AppsLocalState, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.ApplicationLocalState)
	fc.Result = res
	return ec.marshalNApplicationLocalState2githubcomalgorandindexerapigraphmodelApplicationLocalState(ctx, field.Selections, res)
}

func (ec *executionContext) _Account_appLocalState(ctx context.Context, field graphql.CollectedField, obj *model.Account) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Account_appLocalState_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Account().AppLocalState(rctx, obj, args["id"].(uint64))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ApplicationLocalState)
	fc.Result = res
	return ec.marshalOApplicationLocalState2githubcomalgorandindexerapigraphmodelApplicationLocalState(ctx, field.Selections, res)
}

func (ec *executionContext) _Account_appsTotalExtraPages(ctx context.Context, field graphql.CollectedField, obj *model.Account) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AppsTotalExtraPages, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _Account_appsTotalSchema(ctx context.Context, field graphql.CollectedField, obj *model.Account) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AppsTotalSchema, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ApplicationStateSchema)
	fc.Result = res
	return ec.marshalNApplicationStateSchema2githubcomalgorandindexerapigraphmodelApplicationStateSchema(ctx, field.Selections, res)
}

func (ec *executionContext) _Account_assets(ctx context.Context, field graphql.CollectedField, obj *model.Account) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Assets, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.AssetHolding)
	fc.Result = res
	return ec.marshalNAssetHolding2githubcomalgorandindexerapigraphmodelAssetHolding(ctx, field.Selections, res)
}

func (ec *executionContext) _Account_asset(ctx context.Context, field graphql.CollectedField, obj *model.Account) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Account_asset_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Account().Asset(rctx, obj, args["id"].(uint64))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.AssetHolding)
	fc.Result = res
	return ec.marshalOAssetHolding2githubcomalgorandindexerapigraphmodelAssetHolding(ctx, field.Selections, res)
}

func (ec *executionContext) _Account_authAddr(ctx context.Context, field graphql.CollectedField, obj *model.Account) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuthAddr, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOAddress2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Account_authAccount(ctx context.Context, field graphql.CollectedField, obj *model.Account) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Account().AuthAccount(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Account)
	fc.Result = res
	return ec.marshalOAccount2githubcomalgorandindexerapigraphmodelAccount(ctx, field.Selections, res)
}

func (ec *executionContext) _Account_closedAtRound(ctx context.Context, field graphql.CollectedField, obj *model.Account) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClosedAtRound, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _Account_createdApps(ctx context.Context, field graphql.CollectedField, obj *model.Account) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedApps, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.Application)
	fc.Result = res
	return ec.marshalNApplication2githubcomalgorandindexerapigraphmodelApplication(ctx, field.Selections, res)
}

func (ec *executionContext) _Account_createdApp(ctx context.Context, field graphql.CollectedField, obj *model.Account) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Account_createdApp_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Account().CreatedApp(rctx, obj, args["id"].(uint64))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Application)
	fc.Result = res
	return ec.marshalOApplication2githubcomalgorandindexerapigraphmodelApplication(ctx, field.Selections, res)
}

func (ec *executionContext) _Account_createdAssets(ctx context.Context, field graphql.CollectedField, obj *model.Account) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAssets, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.Asset)
	fc.Result = res
	return ec.marshalNAsset2githubcomalgorandindexerapigraphmodelAsset(ctx, field.Selections, res)
}

func (ec *executionContext) _Account_createdAsset(ctx context.Context, field graphql.CollectedField, obj *model.Account) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Account_createdAsset_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Account().CreatedAsset(rctx, obj, args["id"].(uint64))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Asset)
	fc.Result = res
	return ec.marshalOAsset2githubcomalgorandindexerapigraphmodelAsset(ctx, field.Selections, res)
}

func (ec *executionContext) _Account_createdAtRound(ctx context.Context, field graphql.CollectedField, obj *model.Account) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAtRound, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _Account_deleted(ctx context.Context, field graphql.CollectedField, obj *model.Account) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Deleted, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Account_participation(ctx context.Context, field graphql.CollectedField, obj *model.Account) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Participation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.AccountParticipation)
	fc.Result = res
	return ec.marshalOAccountParticipation2githubcomalgorandindexerapigraphmodelAccountParticipation(ctx, field.Selections, res)
}

func (ec *executionContext) _Account_pendingRewards(ctx context.Context, field graphql.CollectedField, obj *model.Account) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PendingRewards, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _Account_rewardBase(ctx context.Context, field graphql.CollectedField, obj *model.Account) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RewardBase, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _Account_rewards(ctx context.Context, field graphql.CollectedField, obj *model.Account) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Rewards, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _Account_round(ctx context.Context, field graphql.CollectedField, obj *model.Account) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Round, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _Account_sigType(ctx context.Context, field graphql.CollectedField, obj *model.Account) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SigType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.SigType)
	fc.Result = res
	return ec.marshalOSigType2githubcomalgorandindexerapigraphmodelSigType(ctx, field.Selections, res)
}

func (ec *executionContext) _Account_status(ctx context.Context, field graphql.CollectedField, obj *model.Account) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Account",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.AccountStatus)
	fc.Result = res
	return ec.marshalNAccountStatus2githubcomalgorandindexerapigraphmodelAccountStatus(ctx, field.Selections, res)
}

func (ec *executionContext) _AccountParticipation_selectionParticipationKey(ctx context.Context, field graphql.CollectedField, obj *model.AccountParticipation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AccountParticipation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SelectionParticipationKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]byte)
	fc.Result = res
	return ec.marshalNBytes2byte(ctx, field.Selections, res)
}

func (ec *executionContext) _AccountParticipation_voteFirstValid(ctx context.Context, field graphql.CollectedField, obj *model.AccountParticipation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AccountParticipation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VoteFirstValid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _AccountParticipation_voteKeyDilution(ctx context.Context, field graphql.CollectedField, obj *model.AccountParticipation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AccountParticipation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VoteKeyDilution, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _AccountParticipation_voteLastValid(ctx context.Context, field graphql.CollectedField, obj *model.AccountParticipation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AccountParticipation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VoteLastValid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _AccountParticipation_voteParticipationKey(ctx context.Context, field graphql.CollectedField, obj *model.AccountParticipation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AccountParticipation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VoteParticipationKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]byte)
	fc.Result = res
	return ec.marshalNBytes2byte(ctx, field.Selections, res)
}

func (ec *executionContext) _AccountResponse_account(ctx context.Context, field graphql.CollectedField, obj *model.AccountResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AccountResponse",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Account, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Account)
	fc.Result = res
	return ec.marshalNAccount2githubcomalgorandindexerapigraphmodelAccount(ctx, field.Selections, res)
}

func (ec *executionContext) _AccountResponse_currentRound(ctx context.Context, field graphql.CollectedField, obj *model.AccountResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AccountResponse",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CurrentRound, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _AccountStateDelta_address(ctx context.Context, field graphql.CollectedField, obj *model.AccountStateDelta) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AccountStateDelta",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Address, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNAddress2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AccountStateDelta_delta(ctx context.Context, field graphql.CollectedField, obj *model.AccountStateDelta) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AccountStateDelta",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Delta, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.EvalDeltaKeyValue)
	fc.Result = res
	return ec.marshalNEvalDeltaKeyValue2githubcomalgorandindexerapigraphmodelEvalDeltaKeyValue(ctx, field.Selections, res)
}

func (ec *executionContext) _AccountUpdateResponse_account(ctx context.Context, field graphql.CollectedField, obj *model.AccountUpdateResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AccountUpdateResponse",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.AccountUpdateResponse().Account(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Account)
	fc.Result = res
	return ec.marshalNAccount2githubcomalgorandindexerapigraphmodelAccount(ctx, field.Selections, res)
}

func (ec *executionContext) _AccountUpdateResponse_transactions(ctx context.Context, field graphql.CollectedField, obj *model.AccountUpdateResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AccountUpdateResponse",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Transactions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.Transaction)
	fc.Result = res
	return ec.marshalNTransaction2githubcomalgorandindexerapigraphmodelTransaction(ctx, field.Selections, res)
}

func (ec *executionContext) _AccountsResponse_accounts(ctx context.Context, field graphql.CollectedField, obj *model.AccountsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AccountsResponse",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Accounts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.Account)
	fc.Result = res
	return ec.marshalNAccount2githubcomalgorandindexerapigraphmodelAccount(ctx, field.Selections, res)
}

func (ec *executionContext) _AccountsResponse_currentRound(ctx context.Context, field graphql.CollectedField, obj *model.AccountsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AccountsResponse",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CurrentRound, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _AccountsResponse_nextToken(ctx context.Context, field graphql.CollectedField, obj *model.AccountsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AccountsResponse",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NextToken, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Application_createdAtRound(ctx context.Context, field graphql.CollectedField, obj *model.Application) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAtRound, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _Application_deleted(ctx context.Context, field graphql.CollectedField, obj *model.Application) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Deleted, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Application_deletedAtRound(ctx context.Context, field graphql.CollectedField, obj *model.Application) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAtRound, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _Application_id(ctx context.Context, field graphql.CollectedField, obj *model.Application) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _Application_params(ctx context.Context, field graphql.CollectedField, obj *model.Application) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Application",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Params, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ApplicationParams)
	fc.Result = res
	return ec.marshalNApplicationParams2githubcomalgorandindexerapigraphmodelApplicationParams(ctx, field.Selections, res)
}

func (ec *executionContext) _ApplicationLocalState_closedOutAtRound(ctx context.Context, field graphql.CollectedField, obj *model.ApplicationLocalState) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ApplicationLocalState",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClosedOutAtRound, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _ApplicationLocalState_deleted(ctx context.Context, field graphql.CollectedField, obj *model.ApplicationLocalState) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ApplicationLocalState",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Deleted, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _ApplicationLocalState_id(ctx context.Context, field graphql.CollectedField, obj *model.ApplicationLocalState) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ApplicationLocalState",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _ApplicationLocalState_application(ctx context.Context, field graphql.CollectedField, obj *model.ApplicationLocalState) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ApplicationLocalState",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ApplicationLocalState().Application(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Application)
	fc.Result = res
	return ec.marshalNApplication2githubcomalgorandindexerapigraphmodelApplication(ctx, field.Selections, res)
}

func (ec *executionContext) _ApplicationLocalState_keyValue(ctx context.Context, field graphql.CollectedField, obj *model.ApplicationLocalState) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ApplicationLocalState",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.KeyValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.TealKeyValue)
	fc.Result = res
	return ec.marshalOTealKeyValue2githubcomalgorandindexerapigraphmodelTealKeyValue(ctx, field.Selections, res)
}

func (ec *executionContext) _ApplicationLocalState_optedInAtRound(ctx context.Context, field graphql.CollectedField, obj *model.ApplicationLocalState) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ApplicationLocalState",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OptedInAtRound, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _ApplicationLocalState_schema(ctx context.Context, field graphql.CollectedField, obj *model.ApplicationLocalState) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ApplicationLocalState",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Schema, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ApplicationStateSchema)
	fc.Result = res
	return ec.marshalNApplicationStateSchema2githubcomalgorandindexerapigraphmodelApplicationStateSchema(ctx, field.Selections, res)
}

func (ec *executionContext) _ApplicationParams_approvalProgram(ctx context.Context, field graphql.CollectedField, obj *model.ApplicationParams) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ApplicationParams",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ApprovalProgram, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]byte)
	fc.Result = res
	return ec.marshalNBytes2byte(ctx, field.Selections, res)
}

func (ec *executionContext) _ApplicationParams_clearStateProgram(ctx context.Context, field graphql.CollectedField, obj *model.ApplicationParams) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ApplicationParams",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClearStateProgram, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]byte)
	fc.Result = res
	return ec.marshalNBytes2byte(ctx, field.Selections, res)
}

func (ec *executionContext) _ApplicationParams_creator(ctx context.Context, field graphql.CollectedField, obj *model.ApplicationParams) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ApplicationParams",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Creator, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNAddress2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ApplicationParams_creatorAccount(ctx context.Context, field graphql.CollectedField, obj *model.ApplicationParams) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ApplicationParams",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ApplicationParams().CreatorAccount(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Account)
	fc.Result = res
	return ec.marshalNAccount2githubcomalgorandindexerapigraphmodelAccount(ctx, field.Selections, res)
}

func (ec *executionContext) _ApplicationParams_extraProgramPages(ctx context.Context, field graphql.CollectedField, obj *model.ApplicationParams) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ApplicationParams",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExtraProgramPages, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _ApplicationParams_globalState(ctx context.Context, field graphql.CollectedField, obj *model.ApplicationParams) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ApplicationParams",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GlobalState, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.TealKeyValue)
	fc.Result = res
	return ec.marshalNTealKeyValue2githubcomalgorandindexerapigraphmodelTealKeyValue(ctx, field.Selections, res)
}

func (ec *executionContext) _ApplicationParams_globalStateSchema(ctx context.Context, field graphql.CollectedField, obj *model.ApplicationParams) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ApplicationParams",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GlobalStateSchema, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ApplicationStateSchema)
	fc.Result = res
	return ec.marshalNApplicationStateSchema2githubcomalgorandindexerapigraphmodelApplicationStateSchema(ctx, field.Selections, res)
}

func (ec *executionContext) _ApplicationParams_localStateSchema(ctx context.Context, field graphql.CollectedField, obj *model.ApplicationParams) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ApplicationParams",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LocalStateSchema, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ApplicationStateSchema)
	fc.Result = res
	return ec.marshalNApplicationStateSchema2githubcomalgorandindexerapigraphmodelApplicationStateSchema(ctx, field.Selections, res)
}

func (ec *executionContext) _ApplicationResponse_application(ctx context.Context, field graphql.CollectedField, obj *model.ApplicationResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ApplicationResponse",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Application, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Application)
	fc.Result = res
	return ec.marshalOApplication2githubcomalgorandindexerapigraphmodelApplication(ctx, field.Selections, res)
}

func (ec *executionContext) _ApplicationResponse_currentRound(ctx context.Context, field graphql.CollectedField, obj *model.ApplicationResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ApplicationResponse",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CurrentRound, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _ApplicationStateSchema_numByteSlice(ctx context.Context, field graphql.CollectedField, obj *model.ApplicationStateSchema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ApplicationStateSchema",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NumByteSlice, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _ApplicationStateSchema_numUint(ctx context.Context, field graphql.CollectedField, obj *model.ApplicationStateSchema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ApplicationStateSchema",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NumUint, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _ApplicationsResponse_applications(ctx context.Context, field graphql.CollectedField, obj *model.ApplicationsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ApplicationsResponse",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Applications, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.Application)
	fc.Result = res
	return ec.marshalNApplication2githubcomalgorandindexerapigraphmodelApplication(ctx, field.Selections, res)
}

func (ec *executionContext) _ApplicationsResponse_currentRound(ctx context.Context, field graphql.CollectedField, obj *model.ApplicationsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ApplicationsResponse",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CurrentRound, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _ApplicationsResponse_nextToken(ctx context.Context, field graphql.CollectedField, obj *model.ApplicationsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "ApplicationsResponse",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NextToken, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Asset_createdAtRound(ctx context.Context, field graphql.CollectedField, obj *model.Asset) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Asset",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAtRound, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _Asset_deleted(ctx context.Context, field graphql.CollectedField, obj *model.Asset) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Asset",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Deleted, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Asset_destroyedAtRound(ctx context.Context, field graphql.CollectedField, obj *model.Asset) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Asset",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DestroyedAtRound, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _Asset_id(ctx context.Context, field graphql.CollectedField, obj *model.Asset) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Asset",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _Asset_params(ctx context.Context, field graphql.CollectedField, obj *model.Asset) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Asset",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Params, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.AssetParams)
	fc.Result = res
	return ec.marshalNAssetParams2githubcomalgorandindexerapigraphmodelAssetParams(ctx, field.Selections, res)
}

func (ec *executionContext) _AssetBalancesResponse_balances(ctx context.Context, field graphql.CollectedField, obj *model.AssetBalancesResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AssetBalancesResponse",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Balances, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.MiniAssetHolding)
	fc.Result = res
	return ec.marshalNMiniAssetHolding2githubcomalgorandindexerapigraphmodelMiniAssetHolding(ctx, field.Selections, res)
}

func (ec *executionContext) _AssetBalancesResponse_currentRound(ctx context.Context, field graphql.CollectedField, obj *model.AssetBalancesResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AssetBalancesResponse",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CurrentRound, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _AssetBalancesResponse_nextToken(ctx context.Context, field graphql.CollectedField, obj *model.AssetBalancesResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AssetBalancesResponse",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NextToken, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AssetHolding_amount(ctx context.Context, field graphql.CollectedField, obj *model.AssetHolding) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AssetHolding",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Amount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _AssetHolding_id(ctx context.Context, field graphql.CollectedField, obj *model.AssetHolding) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AssetHolding",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _AssetHolding_asset(ctx context.Context, field graphql.CollectedField, obj *model.AssetHolding) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AssetHolding",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.AssetHolding().Asset(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Asset)
	fc.Result = res
	return ec.marshalNAsset2githubcomalgorandindexerapigraphmodelAsset(ctx, field.Selections, res)
}

func (ec *executionContext) _AssetHolding_creator(ctx context.Context, field graphql.CollectedField, obj *model.AssetHolding) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AssetHolding",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Creator, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNAddress2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AssetHolding_deleted(ctx context.Context, field graphql.CollectedField, obj *model.AssetHolding) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AssetHolding",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Deleted, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _AssetHolding_frozen(ctx context.Context, field graphql.CollectedField, obj *model.AssetHolding) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AssetHolding",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Frozen, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _AssetHolding_optedInAtRound(ctx context.Context, field graphql.CollectedField, obj *model.AssetHolding) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AssetHolding",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OptedInAtRound, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _AssetHolding_optedOutAtRound(ctx context.Context, field graphql.CollectedField, obj *model.AssetHolding) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AssetHolding",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OptedOutAtRound, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _AssetParams_clawback(ctx context.Context, field graphql.CollectedField, obj *model.AssetParams) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AssetParams",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Clawback, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOAddress2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AssetParams_clawbackAccount(ctx context.Context, field graphql.CollectedField, obj *model.AssetParams) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AssetParams",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.AssetParams().ClawbackAccount(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Account)
	fc.Result = res
	return ec.marshalOAccount2githubcomalgorandindexerapigraphmodelAccount(ctx, field.Selections, res)
}

func (ec *executionContext) _AssetParams_creator(ctx context.Context, field graphql.CollectedField, obj *model.AssetParams) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AssetParams",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Creator, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNAddress2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AssetParams_creatorAccount(ctx context.Context, field graphql.CollectedField, obj *model.AssetParams) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AssetParams",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.AssetParams().CreatorAccount(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Account)
	fc.Result = res
	return ec.marshalNAccount2githubcomalgorandindexerapigraphmodelAccount(ctx, field.Selections, res)
}

func (ec *executionContext) _AssetParams_decimals(ctx context.Context, field graphql.CollectedField, obj *model.AssetParams) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AssetParams",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Decimals, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _AssetParams_defaultFrozen(ctx context.Context, field graphql.CollectedField, obj *model.AssetParams) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AssetParams",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultFrozen, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _AssetParams_freeze(ctx context.Context, field graphql.CollectedField, obj *model.AssetParams) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AssetParams",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Freeze, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOAddress2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AssetParams_freezeAccount(ctx context.Context, field graphql.CollectedField, obj *model.AssetParams) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AssetParams",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.AssetParams().FreezeAccount(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Account)
	fc.Result = res
	return ec.marshalOAccount2githubcomalgorandindexerapigraphmodelAccount(ctx, field.Selections, res)
}

func (ec *executionContext) _AssetParams_manager(ctx context.Context, field graphql.CollectedField, obj *model.AssetParams) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AssetParams",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Manager, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOAddress2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AssetParams_managerAccount(ctx context.Context, field graphql.CollectedField, obj *model.AssetParams) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AssetParams",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.AssetParams().ManagerAccount(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Account)
	fc.Result = res
	return ec.marshalOAccount2githubcomalgorandindexerapigraphmodelAccount(ctx, field.Selections, res)
}

func (ec *executionContext) _AssetParams_metadataHash(ctx context.Context, field graphql.CollectedField, obj *model.AssetParams) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AssetParams",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MetadataHash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]byte)
	fc.Result = res
	return ec.marshalOBytes2byte(ctx, field.Selections, res)
}

func (ec *executionContext) _AssetParams_name(ctx context.Context, field graphql.CollectedField, obj *model.AssetParams) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AssetParams",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AssetParams_reserve(ctx context.Context, field graphql.CollectedField, obj *model.AssetParams) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AssetParams",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reserve, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOAddress2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AssetParams_reserveAccount(ctx context.Context, field graphql.CollectedField, obj *model.AssetParams) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AssetParams",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.AssetParams().ReserveAccount(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Account)
	fc.Result = res
	return ec.marshalOAccount2githubcomalgorandindexerapigraphmodelAccount(ctx, field.Selections, res)
}

func (ec *executionContext) _AssetParams_total(ctx context.Context, field graphql.CollectedField, obj *model.AssetParams) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AssetParams",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _AssetParams_unitName(ctx context.Context, field graphql.CollectedField, obj *model.AssetParams) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AssetParams",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UnitName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AssetParams_url(ctx context.Context, field graphql.CollectedField, obj *model.AssetParams) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AssetParams",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AssetResponse_asset(ctx context.Context, field graphql.CollectedField, obj *model.AssetResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AssetResponse",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Asset, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Asset)
	fc.Result = res
	return ec.marshalNAsset2githubcomalgorandindexerapigraphmodelAsset(ctx, field.Selections, res)
}

func (ec *executionContext) _AssetResponse_currentRound(ctx context.Context, field graphql.CollectedField, obj *model.AssetResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AssetResponse",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CurrentRound, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _AssetsResponse_assets(ctx context.Context, field graphql.CollectedField, obj *model.AssetsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AssetsResponse",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Assets, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.Asset)
	fc.Result = res
	return ec.marshalNAsset2githubcomalgorandindexerapigraphmodelAsset(ctx, field.Selections, res)
}

func (ec *executionContext) _AssetsResponse_currentRound(ctx context.Context, field graphql.CollectedField, obj *model.AssetsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AssetsResponse",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CurrentRound, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _AssetsResponse_nextToken(ctx context.Context, field graphql.CollectedField, obj *model.AssetsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AssetsResponse",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NextToken, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Block_genesisHash(ctx context.Context, field graphql.CollectedField, obj *model.Block) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Block",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GenesisHash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]byte)
	fc.Result = res
	return ec.marshalNBytes2byte(ctx, field.Selections, res)
}

func (ec *executionContext) _Block_genesisId(ctx context.Context, field graphql.CollectedField, obj *model.Block) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Block",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GenesisID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Block_previousBlockHash(ctx context.Context, field graphql.CollectedField, obj *model.Block) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Block",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreviousBlockHash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]byte)
	fc.Result = res
	return ec.marshalNBytes2byte(ctx, field.Selections, res)
}

func (ec *executionContext) _Block_rewards(ctx context.Context, field graphql.CollectedField, obj *model.Block) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Block",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Rewards, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.BlockRewards)
	fc.Result = res
	return ec.marshalOBlockRewards2githubcomalgorandindexerapigraphmodelBlockRewards(ctx, field.Selections, res)
}

func (ec *executionContext) _Block_round(ctx context.Context, field graphql.CollectedField, obj *model.Block) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Block",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Round, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _Block_seed(ctx context.Context, field graphql.CollectedField, obj *model.Block) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Block",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Seed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]byte)
	fc.Result = res
	return ec.marshalNBytes2byte(ctx, field.Selections, res)
}

func (ec *executionContext) _Block_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.Block) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Block",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _Block_transactions(ctx context.Context, field graphql.CollectedField, obj *model.Block) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Block",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Transactions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.Transaction)
	fc.Result = res
	return ec.marshalNTransaction2githubcomalgorandindexerapigraphmodelTransaction(ctx, field.Selections, res)
}

func (ec *executionContext) _Block_transactionsRoot(ctx context.Context, field graphql.CollectedField, obj *model.Block) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Block",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TransactionsRoot, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]byte)
	fc.Result = res
	return ec.marshalNBytes2byte(ctx, field.Selections, res)
}

func (ec *executionContext) _Block_txnCounter(ctx context.Context, field graphql.CollectedField, obj *model.Block) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Block",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TxnCounter, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _Block_upgradeState(ctx context.Context, field graphql.CollectedField, obj *model.Block) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Block",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpgradeState, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.BlockUpgradeState)
	fc.Result = res
	return ec.marshalOBlockUpgradeState2githubcomalgorandindexerapigraphmodelBlockUpgradeState(ctx, field.Selections, res)
}

func (ec *executionContext) _Block_upgradeVote(ctx context.Context, field graphql.CollectedField, obj *model.Block) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Block",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpgradeVote, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.BlockUpgradeVote)
	fc.Result = res
	return ec.marshalOBlockUpgradeVote2githubcomalgorandindexerapigraphmodelBlockUpgradeVote(ctx, field.Selections, res)
}

func (ec *executionContext) _BlockRewards_feeSink(ctx context.Context, field graphql.CollectedField, obj *model.BlockRewards) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "BlockRewards",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeeSink, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNAddress2string(ctx, field.Selections, res)
}

func (ec *executionContext) _BlockRewards_rewardsCalculationRound(ctx context.Context, field graphql.CollectedField, obj *model.BlockRewards) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "BlockRewards",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RewardsCalculationRound, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _BlockRewards_rewardsLevel(ctx context.Context, field graphql.CollectedField, obj *model.BlockRewards) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "BlockRewards",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RewardsLevel, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _BlockRewards_rewardsPool(ctx context.Context, field graphql.CollectedField, obj *model.BlockRewards) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "BlockRewards",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RewardsPool, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNAddress2string(ctx, field.Selections, res)
}

func (ec *executionContext) _BlockRewards_rewardsRate(ctx context.Context, field graphql.CollectedField, obj *model.BlockRewards) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "BlockRewards",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RewardsRate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _BlockRewards_rewardsResidue(ctx context.Context, field graphql.CollectedField, obj *model.BlockRewards) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "BlockRewards",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RewardsResidue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _BlockUpgradeState_currentProtocol(ctx context.Context, field graphql.CollectedField, obj *model.BlockUpgradeState) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "BlockUpgradeState",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CurrentProtocol, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _BlockUpgradeState_nextProtocol(ctx context.Context, field graphql.CollectedField, obj *model.BlockUpgradeState) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "BlockUpgradeState",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NextProtocol, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _BlockUpgradeState_nextProtocolApprovals(ctx context.Context, field graphql.CollectedField, obj *model.BlockUpgradeState) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "BlockUpgradeState",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NextProtocolApprovals, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _BlockUpgradeState_nextProtocolSwitchOn(ctx context.Context, field graphql.CollectedField, obj *model.BlockUpgradeState) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "BlockUpgradeState",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NextProtocolSwitchOn, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _BlockUpgradeState_nextProtocolVoteBefore(ctx context.Context, field graphql.CollectedField, obj *model.BlockUpgradeState) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "BlockUpgradeState",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NextProtocolVoteBefore, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _BlockUpgradeVote_upgradeApprove(ctx context.Context, field graphql.CollectedField, obj *model.BlockUpgradeVote) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "BlockUpgradeVote",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpgradeApprove, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _BlockUpgradeVote_upgradeDelay(ctx context.Context, field graphql.CollectedField, obj *model.BlockUpgradeVote) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "BlockUpgradeVote",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpgradeDelay, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _BlockUpgradeVote_upgradePropose(ctx context.Context, field graphql.CollectedField, obj *model.BlockUpgradeVote) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "BlockUpgradeVote",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpgradePropose, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _EvalDelta_action(ctx context.Context, field graphql.CollectedField, obj *model.EvalDelta) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "EvalDelta",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Action, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.DeltaAction)
	fc.Result = res
	return ec.marshalNDeltaAction2githubcomalgorandindexerapigraphmodelDeltaAction(ctx, field.Selections, res)
}

func (ec *executionContext) _EvalDelta_bytes(ctx context.Context, field graphql.CollectedField, obj *model.EvalDelta) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "EvalDelta",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Bytes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]byte)
	fc.Result = res
	return ec.marshalOBytes2byte(ctx, field.Selections, res)
}

func (ec *executionContext) _EvalDelta_uint(ctx context.Context, field graphql.CollectedField, obj *model.EvalDelta) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "EvalDelta",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Uint, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _EvalDeltaKeyValue_key(ctx context.Context, field graphql.CollectedField, obj *model.EvalDeltaKeyValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "EvalDeltaKeyValue",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]byte)
	fc.Result = res
	return ec.marshalNBytes2byte(ctx, field.Selections, res)
}

func (ec *executionContext) _EvalDeltaKeyValue_value(ctx context.Context, field graphql.CollectedField, obj *model.EvalDeltaKeyValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "EvalDeltaKeyValue",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.EvalDelta)
	fc.Result = res
	return ec.marshalNEvalDelta2githubcomalgorandindexerapigraphmodelEvalDelta(ctx, field.Selections, res)
}

func (ec *executionContext) _HealthCheck_data(ctx context.Context, field graphql.CollectedField, obj *model.HealthCheck) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "HealthCheck",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _HealthCheck_dbAvailable(ctx context.Context, field graphql.CollectedField, obj *model.HealthCheck) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "HealthCheck",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DbAvailable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _HealthCheck_errors(ctx context.Context, field graphql.CollectedField, obj *model.HealthCheck) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "HealthCheck",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _HealthCheck_isMigrating(ctx context.Context, field graphql.CollectedField, obj *model.HealthCheck) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "HealthCheck",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsMigrating, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _HealthCheck_message(ctx context.Context, field graphql.CollectedField, obj *model.HealthCheck) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "HealthCheck",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _HealthCheck_round(ctx context.Context, field graphql.CollectedField, obj *model.HealthCheck) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "HealthCheck",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Round, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _MiniAssetHolding_address(ctx context.Context, field graphql.CollectedField, obj *model.MiniAssetHolding) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "MiniAssetHolding",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Address, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNAddress2string(ctx, field.Selections, res)
}

func (ec *executionContext) _MiniAssetHolding_account(ctx context.Context, field graphql.CollectedField, obj *model.MiniAssetHolding) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "MiniAssetHolding",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.MiniAssetHolding().Account(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Account)
	fc.Result = res
	return ec.marshalNAccount2githubcomalgorandindexerapigraphmodelAccount(ctx, field.Selections, res)
}

func (ec *executionContext) _MiniAssetHolding_amount(ctx context.Context, field graphql.CollectedField, obj *model.MiniAssetHolding) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "MiniAssetHolding",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Amount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _MiniAssetHolding_deleted(ctx context.Context, field graphql.CollectedField, obj *model.MiniAssetHolding) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "MiniAssetHolding",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Deleted, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _MiniAssetHolding_frozen(ctx context.Context, field graphql.CollectedField, obj *model.MiniAssetHolding) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "MiniAssetHolding",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Frozen, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _MiniAssetHolding_optedInAtRound(ctx context.Context, field graphql.CollectedField, obj *model.MiniAssetHolding) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "MiniAssetHolding",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OptedInAtRound, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _MiniAssetHolding_optedOutAtRound(ctx context.Context, field graphql.CollectedField, obj *model.MiniAssetHolding) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "MiniAssetHolding",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OptedOutAtRound, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_block(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_block_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Block(rctx, args["roundNumber"].(uint64))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Block)
	fc.Result = res
	return ec.marshalOBlock2githubcomalgorandindexerapigraphmodelBlock(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_healthCheck(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().HealthCheck(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.HealthCheck)
	fc.Result = res
	return ec.marshalOHealthCheck2githubcomalgorandindexerapigraphmodelHealthCheck(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_account(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_account_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Account(rctx, args["address"].(string), args["includeAll"].(*bool), args["round"].(*uint64))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.AccountResponse)
	fc.Result = res
	return ec.marshalOAccountResponse2githubcomalgorandindexerapigraphmodelAccountResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_accountTransactions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_accountTransactions_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AccountTransactions(rctx, args["account"].(string), args["afterTime"].(*time.Time), args["assetId"].(*uint64), args["beforeTime"].(*time.Time), args["currencyGreaterThan"].(*uint64), args["currencyLessThan"].(*uint64), args["limit"].(*uint64), args["maxRound"].(*uint64), args["minRound"].(*uint64), args["next"].(*string), args["notePrefix"].([]byte), args["rekeyTo"].(*bool), args["round"].(*uint64), args["sigType"].(*model.SigType), args["txType"].(*model.TxType), args["id"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.TransactionsResponse)
	fc.Result = res
	return ec.marshalOTransactionsResponse2githubcomalgorandindexerapigraphmodelTransactionsResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_accounts(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_accounts_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Accounts(rctx, args["applicationId"].(*uint64), args["assetId"].(*uint64), args["authAddr"].(*string), args["currencyGreaterThan"].(*uint64), args["currencyLessThan"].(*uint64), args["includeAll"].(*bool), args["limit"].(*uint64), args["next"].(*string), args["round"].(*uint64))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.AccountsResponse)
	fc.Result = res
	return ec.marshalOAccountsResponse2githubcomalgorandindexerapigraphmodelAccountsResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_application(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_application_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Application(rctx, args["id"].(uint64), args["includeAll"].(*bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ApplicationResponse)
	fc.Result = res
	return ec.marshalOApplicationResponse2githubcomalgorandindexerapigraphmodelApplicationResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_applications(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_applications_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Applications(rctx, args["id"].(*uint64), args["includeAll"].(*bool), args["limit"].(*uint64), args["next"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ApplicationsResponse)
	fc.Result = res
	return ec.marshalOApplicationsResponse2githubcomalgorandindexerapigraphmodelApplicationsResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_asset(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_asset_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Asset(rctx, args["id"].(uint64), args["includeAll"].(*bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.AssetResponse)
	fc.Result = res
	return ec.marshalOAssetResponse2githubcomalgorandindexerapigraphmodelAssetResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_assetBalances(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_assetBalances_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AssetBalances(rctx, args["assetId"].(uint64), args["currencyGreaterThan"].(*uint64), args["currencyLessThan"].(*uint64), args["includeAll"].(*bool), args["limit"].(*uint64), args["next"].(*string), args["round"].(*uint64))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.AssetBalancesResponse)
	fc.Result = res
	return ec.marshalOAssetBalancesResponse2githubcomalgorandindexerapigraphmodelAssetBalancesResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_assetTransactions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_assetTransactions_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AssetTransactions(rctx, args["address"].(*string), args["addressRole"].(*model.AddressRole), args["afterTime"].(*time.Time), args["assetId"].(uint64), args["beforeTime"].(*time.Time), args["currencyGreaterThan"].(*uint64), args["currencyLessThan"].(*uint64), args["excludeCloseTo"].(*bool), args["limit"].(*uint64), args["maxRound"].(*uint64), args["minRound"].(*uint64), args["next"].(*string), args["notePrefix"].([]byte), args["rekeyTo"].(*bool), args["round"].(*uint64), args["sigType"].(*model.SigType), args["txType"].(*model.TxType), args["id"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.TransactionsResponse)
	fc.Result = res
	return ec.marshalOTransactionsResponse2githubcomalgorandindexerapigraphmodelTransactionsResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_assets(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_assets_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Assets(rctx, args["id"].(*uint64), args["creator"].(*string), args["includeAll"].(*bool), args["limit"].(*uint64), args["name"].(*string), args["next"].(*string), args["unit"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.AssetsResponse)
	fc.Result = res
	return ec.marshalOAssetsResponse2githubcomalgorandindexerapigraphmodelAssetsResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_transaction(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_transaction_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Transaction(rctx, args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.TransactionResponse)
	fc.Result = res
	return ec.marshalOTransactionResponse2githubcomalgorandindexerapigraphmodelTransactionResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_transactions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_transactions_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Transactions(rctx, args["address"].(*string), args["addressRole"].(*model.AddressRole), args["afterTime"].(*time.Time), args["applicationId"].(*uint64), args["assetId"].(*uint64), args["beforeTime"].(*time.Time), args["currencyGreaterThan"].(*uint64), args["currencyLessThan"].(*uint64), args["excludeCloseTo"].(*bool), args["limit"].(*uint64), args["maxRound"].(*uint64), args["minRound"].(*uint64), args["next"].(*string), args["notePrefix"].([]byte), args["rekeyTo"].(*bool), args["round"].(*uint64), args["sigType"].(*model.SigType), args["txType"].(*model.TxType), args["id"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.TransactionsResponse)
	fc.Result = res
	return ec.marshalOTransactionsResponse2githubcomalgorandindexerapigraphmodelTransactionsResponse(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query___type_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx, field.Selections, res)
}

func (ec *executionContext) _StateSchema_numByteSlice(ctx context.Context, field graphql.CollectedField, obj *model.StateSchema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "StateSchema",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NumByteSlice, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _StateSchema_numUint(ctx context.Context, field graphql.CollectedField, obj *model.StateSchema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "StateSchema",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NumUint, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _Subscription_newBlock(ctx context.Context, field graphql.CollectedField) (ret func() graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().NewBlock(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-resTmp.(<-chan *model.Block)
		if !ok {
			return nil
		}
		return graphql.WriterFunc(func(w io.Writer) {
			w.Write([]byte{'{'})
			graphql.MarshalString(field.Alias).MarshalGQL(w)
			w.Write([]byte{':'})
			ec.marshalOBlock2githubcomalgorandindexerapigraphmodelBlock(ctx, field.Selections, res).MarshalGQL(w)
			w.Write([]byte{'}'})
		})
	}
}

func (ec *executionContext) _Subscription_accountUpdate(ctx context.Context, field graphql.CollectedField) (ret func() graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Subscription_accountUpdate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().AccountUpdate(rctx, args["address"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-resTmp.(<-chan *model.AccountUpdateResponse)
		if !ok {
			return nil
		}
		return graphql.WriterFunc(func(w io.Writer) {
			w.Write([]byte{'{'})
			graphql.MarshalString(field.Alias).MarshalGQL(w)
			w.Write([]byte{':'})
			ec.marshalOAccountUpdateResponse2githubcomalgorandindexerapigraphmodelAccountUpdateResponse(ctx, field.Selections, res).MarshalGQL(w)
			w.Write([]byte{'}'})
		})
	}
}

func (ec *executionContext) _TealKeyValue_key(ctx context.Context, field graphql.CollectedField, obj *model.TealKeyValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TealKeyValue",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]byte)
	fc.Result = res
	return ec.marshalNBytes2byte(ctx, field.Selections, res)
}

func (ec *executionContext) _TealKeyValue_value(ctx context.Context, field graphql.CollectedField, obj *model.TealKeyValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TealKeyValue",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.TealValue)
	fc.Result = res
	return ec.marshalNTealValue2githubcomalgorandindexerapigraphmodelTealValue(ctx, field.Selections, res)
}

func (ec *executionContext) _TealValue_bytes(ctx context.Context, field graphql.CollectedField, obj *model.TealValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TealValue",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Bytes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]byte)
	fc.Result = res
	return ec.marshalNBytes2byte(ctx, field.Selections, res)
}

func (ec *executionContext) _TealValue_type(ctx context.Context, field graphql.CollectedField, obj *model.TealValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TealValue",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _TealValue_uint(ctx context.Context, field graphql.CollectedField, obj *model.TealValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TealValue",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Uint, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _Transaction_applicationTransaction(ctx context.Context, field graphql.CollectedField, obj *model.Transaction) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ApplicationTransaction, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.TransactionApplication)
	fc.Result = res
	return ec.marshalOTransactionApplication2githubcomalgorandindexerapigraphmodelTransactionApplication(ctx, field.Selections, res)
}

func (ec *executionContext) _Transaction_assetConfigTransaction(ctx context.Context, field graphql.CollectedField, obj *model.Transaction) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AssetConfigTransaction, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.TransactionAssetConfig)
	fc.Result = res
	return ec.marshalOTransactionAssetConfig2githubcomalgorandindexerapigraphmodelTransactionAssetConfig(ctx, field.Selections, res)
}

func (ec *executionContext) _Transaction_assetFreezeTransaction(ctx context.Context, field graphql.CollectedField, obj *model.Transaction) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AssetFreezeTransaction, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.TransactionAssetFreeze)
	fc.Result = res
	return ec.marshalOTransactionAssetFreeze2githubcomalgorandindexerapigraphmodelTransactionAssetFreeze(ctx, field.Selections, res)
}

func (ec *executionContext) _Transaction_assetTransferTransaction(ctx context.Context, field graphql.CollectedField, obj *model.Transaction) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AssetTransferTransaction, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.TransactionAssetTransfer)
	fc.Result = res
	return ec.marshalOTransactionAssetTransfer2githubcomalgorandindexerapigraphmodelTransactionAssetTransfer(ctx, field.Selections, res)
}

func (ec *executionContext) _Transaction_authAddr(ctx context.Context, field graphql.CollectedField, obj *model.Transaction) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuthAddr, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOAddress2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Transaction_closeRewards(ctx context.Context, field graphql.CollectedField, obj *model.Transaction) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CloseRewards, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _Transaction_closingAmount(ctx context.Context, field graphql.CollectedField, obj *model.Transaction) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClosingAmount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _Transaction_confirmedRound(ctx context.Context, field graphql.CollectedField, obj *model.Transaction) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConfirmedRound, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _Transaction_createdApplicationId(ctx context.Context, field graphql.CollectedField, obj *model.Transaction) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedApplicationID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _Transaction_createdAssetId(ctx context.Context, field graphql.CollectedField, obj *model.Transaction) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAssetID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _Transaction_fee(ctx context.Context, field graphql.CollectedField, obj *model.Transaction) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fee, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _Transaction_firstValid(ctx context.Context, field graphql.CollectedField, obj *model.Transaction) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FirstValid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _Transaction_genesisHash(ctx context.Context, field graphql.CollectedField, obj *model.Transaction) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GenesisHash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]byte)
	fc.Result = res
	return ec.marshalOBytes2byte(ctx, field.Selections, res)
}

func (ec *executionContext) _Transaction_genesisId(ctx context.Context, field graphql.CollectedField, obj *model.Transaction) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GenesisID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Transaction_globalStateDelta(ctx context.Context, field graphql.CollectedField, obj *model.Transaction) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GlobalStateDelta, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.EvalDeltaKeyValue)
	fc.Result = res
	return ec.marshalOEvalDeltaKeyValue2githubcomalgorandindexerapigraphmodelEvalDeltaKeyValue(ctx, field.Selections, res)
}

func (ec *executionContext) _Transaction_group(ctx context.Context, field graphql.CollectedField, obj *model.Transaction) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Group, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]byte)
	fc.Result = res
	return ec.marshalOBytes2byte(ctx, field.Selections, res)
}

func (ec *executionContext) _Transaction_id(ctx context.Context, field graphql.CollectedField, obj *model.Transaction) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Transaction_intraRoundOffset(ctx context.Context, field graphql.CollectedField, obj *model.Transaction) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IntraRoundOffset, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _Transaction_keyregTransaction(ctx context.Context, field graphql.CollectedField, obj *model.Transaction) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.KeyregTransaction, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.TransactionKeyreg)
	fc.Result = res
	return ec.marshalOTransactionKeyreg2githubcomalgorandindexerapigraphmodelTransactionKeyreg(ctx, field.Selections, res)
}

func (ec *executionContext) _Transaction_lastValid(ctx context.Context, field graphql.CollectedField, obj *model.Transaction) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastValid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _Transaction_lease(ctx context.Context, field graphql.CollectedField, obj *model.Transaction) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Lease, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]byte)
	fc.Result = res
	return ec.marshalOBytes2byte(ctx, field.Selections, res)
}

func (ec *executionContext) _Transaction_localStateDelta(ctx context.Context, field graphql.CollectedField, obj *model.Transaction) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LocalStateDelta, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.AccountStateDelta)
	fc.Result = res
	return ec.marshalOAccountStateDelta2githubcomalgorandindexerapigraphmodelAccountStateDelta(ctx, field.Selections, res)
}

func (ec *executionContext) _Transaction_note(ctx context.Context, field graphql.CollectedField, obj *model.Transaction) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Note, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]byte)
	fc.Result = res
	return ec.marshalOBytes2byte(ctx, field.Selections, res)
}

func (ec *executionContext) _Transaction_paymentTransaction(ctx context.Context, field graphql.CollectedField, obj *model.Transaction) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PaymentTransaction, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.TransactionPayment)
	fc.Result = res
	return ec.marshalOTransactionPayment2githubcomalgorandindexerapigraphmodelTransactionPayment(ctx, field.Selections, res)
}

func (ec *executionContext) _Transaction_receiverRewards(ctx context.Context, field graphql.CollectedField, obj *model.Transaction) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReceiverRewards, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _Transaction_rekeyTo(ctx context.Context, field graphql.CollectedField, obj *model.Transaction) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RekeyTo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOAddress2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Transaction_roundTime(ctx context.Context, field graphql.CollectedField, obj *model.Transaction) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RoundTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _Transaction_sender(ctx context.Context, field graphql.CollectedField, obj *model.Transaction) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sender, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNAddress2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Transaction_senderRewards(ctx context.Context, field graphql.CollectedField, obj *model.Transaction) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SenderRewards, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _Transaction_signature(ctx context.Context, field graphql.CollectedField, obj *model.Transaction) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Signature, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.TransactionSignature)
	fc.Result = res
	return ec.marshalNTransactionSignature2githubcomalgorandindexerapigraphmodelTransactionSignature(ctx, field.Selections, res)
}

func (ec *executionContext) _Transaction_txType(ctx context.Context, field graphql.CollectedField, obj *model.Transaction) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TxType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.TxType)
	fc.Result = res
	return ec.marshalNTxType2githubcomalgorandindexerapigraphmodelTxType(ctx, field.Selections, res)
}

func (ec *executionContext) _TransactionApplication_accounts(ctx context.Context, field graphql.CollectedField, obj *model.TransactionApplication) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TransactionApplication",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Accounts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNAddress2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TransactionApplication_applicationArgs(ctx context.Context, field graphql.CollectedField, obj *model.TransactionApplication) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TransactionApplication",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ApplicationArgs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([][]byte)
	fc.Result = res
	return ec.marshalNBytes2byte(ctx, field.Selections, res)
}

func (ec *executionContext) _TransactionApplication_applicationId(ctx context.Context, field graphql.CollectedField, obj *model.TransactionApplication) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TransactionApplication",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ApplicationID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _TransactionApplication_approvalProgram(ctx context.Context, field graphql.CollectedField, obj *model.TransactionApplication) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TransactionApplication",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ApprovalProgram, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]byte)
	fc.Result = res
	return ec.marshalOBytes2byte(ctx, field.Selections, res)
}

func (ec *executionContext) _TransactionApplication_clearStateProgram(ctx context.Context, field graphql.CollectedField, obj *model.TransactionApplication) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TransactionApplication",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClearStateProgram, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]byte)
	fc.Result = res
	return ec.marshalOBytes2byte(ctx, field.Selections, res)
}

func (ec *executionContext) _TransactionApplication_extraProgramPages(ctx context.Context, field graphql.CollectedField, obj *model.TransactionApplication) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TransactionApplication",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExtraProgramPages, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _TransactionApplication_foreignApps(ctx context.Context, field graphql.CollectedField, obj *model.TransactionApplication) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TransactionApplication",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ForeignApps, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _TransactionApplication_foreignAssets(ctx context.Context, field graphql.CollectedField, obj *model.TransactionApplication) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TransactionApplication",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ForeignAssets, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _TransactionApplication_globalStateSchema(ctx context.Context, field graphql.CollectedField, obj *model.TransactionApplication) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TransactionApplication",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GlobalStateSchema, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.StateSchema)
	fc.Result = res
	return ec.marshalOStateSchema2githubcomalgorandindexerapigraphmodelStateSchema(ctx, field.Selections, res)
}

func (ec *executionContext) _TransactionApplication_localStateSchema(ctx context.Context, field graphql.CollectedField, obj *model.TransactionApplication) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TransactionApplication",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LocalStateSchema, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.StateSchema)
	fc.Result = res
	return ec.marshalOStateSchema2githubcomalgorandindexerapigraphmodelStateSchema(ctx, field.Selections, res)
}

func (ec *executionContext) _TransactionApplication_onCompletion(ctx context.Context, field graphql.CollectedField, obj *model.TransactionApplication) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TransactionApplication",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OnCompletion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.OnCompletion)
	fc.Result = res
	return ec.marshalNOnCompletion2githubcomalgorandindexerapigraphmodelOnCompletion(ctx, field.Selections, res)
}

func (ec *executionContext) _TransactionAssetConfig_assetId(ctx context.Context, field graphql.CollectedField, obj *model.TransactionAssetConfig) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TransactionAssetConfig",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AssetID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _TransactionAssetConfig_params(ctx context.Context, field graphql.CollectedField, obj *model.TransactionAssetConfig) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TransactionAssetConfig",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Params, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.AssetParams)
	fc.Result = res
	return ec.marshalOAssetParams2githubcomalgorandindexerapigraphmodelAssetParams(ctx, field.Selections, res)
}

func (ec *executionContext) _TransactionAssetFreeze_address(ctx context.Context, field graphql.CollectedField, obj *model.TransactionAssetFreeze) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TransactionAssetFreeze",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Address, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNAddress2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TransactionAssetFreeze_assetId(ctx context.Context, field graphql.CollectedField, obj *model.TransactionAssetFreeze) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TransactionAssetFreeze",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AssetID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _TransactionAssetFreeze_newFreezeStatus(ctx context.Context, field graphql.CollectedField, obj *model.TransactionAssetFreeze) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TransactionAssetFreeze",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NewFreezeStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _TransactionAssetTransfer_amount(ctx context.Context, field graphql.CollectedField, obj *model.TransactionAssetTransfer) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TransactionAssetTransfer",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Amount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _TransactionAssetTransfer_assetId(ctx context.Context, field graphql.CollectedField, obj *model.TransactionAssetTransfer) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TransactionAssetTransfer",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AssetID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _TransactionAssetTransfer_closeAmount(ctx context.Context, field graphql.CollectedField, obj *model.TransactionAssetTransfer) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TransactionAssetTransfer",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CloseAmount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _TransactionAssetTransfer_closeTo(ctx context.Context, field graphql.CollectedField, obj *model.TransactionAssetTransfer) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TransactionAssetTransfer",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CloseTo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOAddress2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TransactionAssetTransfer_receiver(ctx context.Context, field graphql.CollectedField, obj *model.TransactionAssetTransfer) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TransactionAssetTransfer",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Receiver, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNAddress2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TransactionAssetTransfer_sender(ctx context.Context, field graphql.CollectedField, obj *model.TransactionAssetTransfer) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TransactionAssetTransfer",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sender, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOAddress2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TransactionKeyreg_nonParticipation(ctx context.Context, field graphql.CollectedField, obj *model.TransactionKeyreg) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TransactionKeyreg",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NonParticipation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _TransactionKeyreg_selectionParticipationKey(ctx context.Context, field graphql.CollectedField, obj *model.TransactionKeyreg) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TransactionKeyreg",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SelectionParticipationKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]byte)
	fc.Result = res
	return ec.marshalOBytes2byte(ctx, field.Selections, res)
}

func (ec *executionContext) _TransactionKeyreg_voteFirstValid(ctx context.Context, field graphql.CollectedField, obj *model.TransactionKeyreg) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TransactionKeyreg",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VoteFirstValid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _TransactionKeyreg_voteKeyDilution(ctx context.Context, field graphql.CollectedField, obj *model.TransactionKeyreg) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TransactionKeyreg",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VoteKeyDilution, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _TransactionKeyreg_voteLastValid(ctx context.Context, field graphql.CollectedField, obj *model.TransactionKeyreg) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TransactionKeyreg",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VoteLastValid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _TransactionKeyreg_voteParticipationKey(ctx context.Context, field graphql.CollectedField, obj *model.TransactionKeyreg) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TransactionKeyreg",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VoteParticipationKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]byte)
	fc.Result = res
	return ec.marshalOBytes2byte(ctx, field.Selections, res)
}

func (ec *executionContext) _TransactionPayment_amount(ctx context.Context, field graphql.CollectedField, obj *model.TransactionPayment) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TransactionPayment",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Amount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _TransactionPayment_closeAmount(ctx context.Context, field graphql.CollectedField, obj *model.TransactionPayment) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TransactionPayment",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CloseAmount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _TransactionPayment_closeRemainderTo(ctx context.Context, field graphql.CollectedField, obj *model.TransactionPayment) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TransactionPayment",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CloseRemainderTo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOAddress2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TransactionPayment_receiver(ctx context.Context, field graphql.CollectedField, obj *model.TransactionPayment) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TransactionPayment",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Receiver, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNAddress2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TransactionResponse_currentRound(ctx context.Context, field graphql.CollectedField, obj *model.TransactionResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TransactionResponse",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CurrentRound, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _TransactionResponse_transaction(ctx context.Context, field graphql.CollectedField, obj *model.TransactionResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TransactionResponse",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Transaction, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Transaction)
	fc.Result = res
	return ec.marshalNTransaction2githubcomalgorandindexerapigraphmodelTransaction(ctx, field.Selections, res)
}

func (ec *executionContext) _TransactionSignature_logicsig(ctx context.Context, field graphql.CollectedField, obj *model.TransactionSignature) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TransactionSignature",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Logicsig, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.TransactionSignatureLogicsig)
	fc.Result = res
	return ec.marshalOTransactionSignatureLogicsig2githubcomalgorandindexerapigraphmodelTransactionSignatureLogicsig(ctx, field.Selections, res)
}

func (ec *executionContext) _TransactionSignature_multisig(ctx context.Context, field graphql.CollectedField, obj *model.TransactionSignature) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TransactionSignature",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Multisig, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.TransactionSignatureMultisig)
	fc.Result = res
	return ec.marshalOTransactionSignatureMultisig2githubcomalgorandindexerapigraphmodelTransactionSignatureMultisig(ctx, field.Selections, res)
}

func (ec *executionContext) _TransactionSignature_sig(ctx context.Context, field graphql.CollectedField, obj *model.TransactionSignature) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TransactionSignature",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sig, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]byte)
	fc.Result = res
	return ec.marshalOBytes2byte(ctx, field.Selections, res)
}

func (ec *executionContext) _TransactionSignatureLogicsig_args(ctx context.Context, field graphql.CollectedField, obj *model.TransactionSignatureLogicsig) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TransactionSignatureLogicsig",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([][]byte)
	fc.Result = res
	return ec.marshalNBytes2byte(ctx, field.Selections, res)
}

func (ec *executionContext) _TransactionSignatureLogicsig_logic(ctx context.Context, field graphql.CollectedField, obj *model.TransactionSignatureLogicsig) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TransactionSignatureLogicsig",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Logic, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]byte)
	fc.Result = res
	return ec.marshalNBytes2byte(ctx, field.Selections, res)
}

func (ec *executionContext) _TransactionSignatureLogicsig_multisigSignature(ctx context.Context, field graphql.CollectedField, obj *model.TransactionSignatureLogicsig) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TransactionSignatureLogicsig",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MultisigSignature, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.TransactionSignatureMultisig)
	fc.Result = res
	return ec.marshalOTransactionSignatureMultisig2githubcomalgorandindexerapigraphmodelTransactionSignatureMultisig(ctx, field.Selections, res)
}

func (ec *executionContext) _TransactionSignatureLogicsig_signature(ctx context.Context, field graphql.CollectedField, obj *model.TransactionSignatureLogicsig) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TransactionSignatureLogicsig",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Signature, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]byte)
	fc.Result = res
	return ec.marshalOBytes2byte(ctx, field.Selections, res)
}

func (ec *executionContext) _TransactionSignatureMultisig_subsignature(ctx context.Context, field graphql.CollectedField, obj *model.TransactionSignatureMultisig) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TransactionSignatureMultisig",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Subsignature, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.TransactionSignatureMultisigSubsignature)
	fc.Result = res
	return ec.marshalOTransactionSignatureMultisigSubsignature2githubcomalgorandindexerapigraphmodelTransactionSignatureMultisigSubsignature(ctx, field.Selections, res)
}

func (ec *executionContext) _TransactionSignatureMultisig_threshold(ctx context.Context, field graphql.CollectedField, obj *model.TransactionSignatureMultisig) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TransactionSignatureMultisig",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Threshold, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _TransactionSignatureMultisig_version(ctx context.Context, field graphql.CollectedField, obj *model.TransactionSignatureMultisig) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TransactionSignatureMultisig",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint64)
	fc.Result = res
	return ec.marshalOUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _TransactionSignatureMultisigSubsignature_publicKey(ctx context.Context, field graphql.CollectedField, obj *model.TransactionSignatureMultisigSubsignature) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TransactionSignatureMultisigSubsignature",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PublicKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]byte)
	fc.Result = res
	return ec.marshalOBytes2byte(ctx, field.Selections, res)
}

func (ec *executionContext) _TransactionSignatureMultisigSubsignature_signature(ctx context.Context, field graphql.CollectedField, obj *model.TransactionSignatureMultisigSubsignature) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TransactionSignatureMultisigSubsignature",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Signature, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]byte)
	fc.Result = res
	return ec.marshalOBytes2byte(ctx, field.Selections, res)
}

func (ec *executionContext) _TransactionsResponse_currentRound(ctx context.Context, field graphql.CollectedField, obj *model.TransactionsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TransactionsResponse",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CurrentRound, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) _TransactionsResponse_nextToken(ctx context.Context, field graphql.CollectedField, obj *model.TransactionsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TransactionsResponse",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NextToken, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TransactionsResponse_transactions(ctx context.Context, field graphql.CollectedField, obj *model.TransactionsResponse) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TransactionsResponse",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Transactions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.Transaction)
	fc.Result = res
	return ec.marshalNTransaction2githubcomalgorandindexerapigraphmodelTransaction(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field___Type_fields_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field___Type_enumValues_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var accountImplementors = []string{"Account"}

func (ec *executionContext) _Account(ctx context.Context, sel ast.SelectionSet, obj *model.Account) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, accountImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Account")
		case "address":
			out.Values[i] = ec._Account_address(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "amount":
			out.Values[i] = ec._Account_amount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "amountWithoutPendingRewards":
			out.Values[i] = ec._Account_amountWithoutPendingRewards(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "appsLocalState":
			out.Values[i] = ec._Account_appsLocalState(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "appLocalState":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Account_appLocalState(ctx, field, obj)
				return res
			})
		case "appsTotalExtraPages":
			out.Values[i] = ec._Account_appsTotalExtraPages(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "appsTotalSchema":
			out.Values[i] = ec._Account_appsTotalSchema(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "assets":
			out.Values[i] = ec._Account_assets(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "asset":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Account_asset(ctx, field, obj)
				return res
			})
		case "authAddr":
			out.Values[i] = ec._Account_authAddr(ctx, field, obj)
		case "authAccount":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Account_authAccount(ctx, field, obj)
				return res
			})
		case "closedAtRound":
			out.Values[i] = ec._Account_closedAtRound(ctx, field, obj)
		case "createdApps":
			out.Values[i] = ec._Account_createdApps(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "createdApp":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Account_createdApp(ctx, field, obj)
				return res
			})
		case "createdAssets":
			out.Values[i] = ec._Account_createdAssets(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "createdAsset":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Account_createdAsset(ctx, field, obj)
				return res
			})
		case "createdAtRound":
			out.Values[i] = ec._Account_createdAtRound(ctx, field, obj)
		case "deleted":
			out.Values[i] = ec._Account_deleted(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "participation":
			out.Values[i] = ec._Account_participation(ctx, field, obj)
		case "pendingRewards":
			out.Values[i] = ec._Account_pendingRewards(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "rewardBase":
			out.Values[i] = ec._Account_rewardBase(ctx, field, obj)
		case "rewards":
			out.Values[i] = ec._Account_rewards(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "round":
			out.Values[i] = ec._Account_round(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "sigType":
			out.Values[i] = ec._Account_sigType(ctx, field, obj)
		case "status":
			out.Values[i] = ec._Account_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var accountParticipationImplementors = []string{"AccountParticipation"}

func (ec *executionContext) _AccountParticipation(ctx context.Context, sel ast.SelectionSet, obj *model.AccountParticipation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, accountParticipationImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AccountParticipation")
		case "selectionParticipationKey":
			out.Values[i] = ec._AccountParticipation_selectionParticipationKey(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "voteFirstValid":
			out.Values[i] = ec._AccountParticipation_voteFirstValid(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "voteKeyDilution":
			out.Values[i] = ec._AccountParticipation_voteKeyDilution(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "voteLastValid":
			out.Values[i] = ec._AccountParticipation_voteLastValid(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "voteParticipationKey":
			out.Values[i] = ec._AccountParticipation_voteParticipationKey(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var accountResponseImplementors = []string{"AccountResponse"}

func (ec *executionContext) _AccountResponse(ctx context.Context, sel ast.SelectionSet, obj *model.AccountResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, accountResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AccountResponse")
		case "account":
			out.Values[i] = ec._AccountResponse_account(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "currentRound":
			out.Values[i] = ec._AccountResponse_currentRound(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var accountStateDeltaImplementors = []string{"AccountStateDelta"}

func (ec *executionContext) _AccountStateDelta(ctx context.Context, sel ast.SelectionSet, obj *model.AccountStateDelta) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, accountStateDeltaImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AccountStateDelta")
		case "address":
			out.Values[i] = ec._AccountStateDelta_address(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "delta":
			out.Values[i] = ec._AccountStateDelta_delta(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var accountUpdateResponseImplementors = []string{"AccountUpdateResponse"}

func (ec *executionContext) _AccountUpdateResponse(ctx context.Context, sel ast.SelectionSet, obj *model.AccountUpdateResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, accountUpdateResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AccountUpdateResponse")
		case "account":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AccountUpdateResponse_account(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "transactions":
			out.Values[i] = ec._AccountUpdateResponse_transactions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var accountsResponseImplementors = []string{"AccountsResponse"}

func (ec *executionContext) _AccountsResponse(ctx context.Context, sel ast.SelectionSet, obj *model.AccountsResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, accountsResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AccountsResponse")
		case "accounts":
			out.Values[i] = ec._AccountsResponse_accounts(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "currentRound":
			out.Values[i] = ec._AccountsResponse_currentRound(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "nextToken":
			out.Values[i] = ec._AccountsResponse_nextToken(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var applicationImplementors = []string{"Application"}

func (ec *executionContext) _Application(ctx context.Context, sel ast.SelectionSet, obj *model.Application) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Application")
		case "createdAtRound":
			out.Values[i] = ec._Application_createdAtRound(ctx, field, obj)
		case "deleted":
			out.Values[i] = ec._Application_deleted(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deletedAtRound":
			out.Values[i] = ec._Application_deletedAtRound(ctx, field, obj)
		case "id":
			out.Values[i] = ec._Application_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "params":
			out.Values[i] = ec._Application_params(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var applicationLocalStateImplementors = []string{"ApplicationLocalState"}

func (ec *executionContext) _ApplicationLocalState(ctx context.Context, sel ast.SelectionSet, obj *model.ApplicationLocalState) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationLocalStateImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationLocalState")
		case "closedOutAtRound":
			out.Values[i] = ec._ApplicationLocalState_closedOutAtRound(ctx, field, obj)
		case "deleted":
			out.Values[i] = ec._ApplicationLocalState_deleted(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "id":
			out.Values[i] = ec._ApplicationLocalState_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "application":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ApplicationLocalState_application(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "keyValue":
			out.Values[i] = ec._ApplicationLocalState_keyValue(ctx, field, obj)
		case "optedInAtRound":
			out.Values[i] = ec._ApplicationLocalState_optedInAtRound(ctx, field, obj)
		case "schema":
			out.Values[i] = ec._ApplicationLocalState_schema(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var applicationParamsImplementors = []string{"ApplicationParams"}

func (ec *executionContext) _ApplicationParams(ctx context.Context, sel ast.SelectionSet, obj *model.ApplicationParams) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationParamsImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationParams")
		case "approvalProgram":
			out.Values[i] = ec._ApplicationParams_approvalProgram(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "clearStateProgram":
			out.Values[i] = ec._ApplicationParams_clearStateProgram(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "creator":
			out.Values[i] = ec._ApplicationParams_creator(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "creatorAccount":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ApplicationParams_creatorAccount(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "extraProgramPages":
			out.Values[i] = ec._ApplicationParams_extraProgramPages(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "globalState":
			out.Values[i] = ec._ApplicationParams_globalState(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "globalStateSchema":
			out.Values[i] = ec._ApplicationParams_globalStateSchema(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "localStateSchema":
			out.Values[i] = ec._ApplicationParams_localStateSchema(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var applicationResponseImplementors = []string{"ApplicationResponse"}

func (ec *executionContext) _ApplicationResponse(ctx context.Context, sel ast.SelectionSet, obj *model.ApplicationResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationResponse")
		case "application":
			out.Values[i] = ec._ApplicationResponse_application(ctx, field, obj)
		case "currentRound":
			out.Values[i] = ec._ApplicationResponse_currentRound(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var applicationStateSchemaImplementors = []string{"ApplicationStateSchema"}

func (ec *executionContext) _ApplicationStateSchema(ctx context.Context, sel ast.SelectionSet, obj *model.ApplicationStateSchema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationStateSchemaImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationStateSchema")
		case "numByteSlice":
			out.Values[i] = ec._ApplicationStateSchema_numByteSlice(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "numUint":
			out.Values[i] = ec._ApplicationStateSchema_numUint(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var applicationsResponseImplementors = []string{"ApplicationsResponse"}

func (ec *executionContext) _ApplicationsResponse(ctx context.Context, sel ast.SelectionSet, obj *model.ApplicationsResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, applicationsResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ApplicationsResponse")
		case "applications":
			out.Values[i] = ec._ApplicationsResponse_applications(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "currentRound":
			out.Values[i] = ec._ApplicationsResponse_currentRound(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "nextToken":
			out.Values[i] = ec._ApplicationsResponse_nextToken(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var assetImplementors = []string{"Asset"}

func (ec *executionContext) _Asset(ctx context.Context, sel ast.SelectionSet, obj *model.Asset) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, assetImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Asset")
		case "createdAtRound":
			out.Values[i] = ec._Asset_createdAtRound(ctx, field, obj)
		case "deleted":
			out.Values[i] = ec._Asset_deleted(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "destroyedAtRound":
			out.Values[i] = ec._Asset_destroyedAtRound(ctx, field, obj)
		case "id":
			out.Values[i] = ec._Asset_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "params":
			out.Values[i] = ec._Asset_params(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var assetBalancesResponseImplementors = []string{"AssetBalancesResponse"}

func (ec *executionContext) _AssetBalancesResponse(ctx context.Context, sel ast.SelectionSet, obj *model.AssetBalancesResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, assetBalancesResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AssetBalancesResponse")
		case "balances":
			out.Values[i] = ec._AssetBalancesResponse_balances(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "currentRound":
			out.Values[i] = ec._AssetBalancesResponse_currentRound(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "nextToken":
			out.Values[i] = ec._AssetBalancesResponse_nextToken(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var assetHoldingImplementors = []string{"AssetHolding"}

func (ec *executionContext) _AssetHolding(ctx context.Context, sel ast.SelectionSet, obj *model.AssetHolding) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, assetHoldingImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AssetHolding")
		case "amount":
			out.Values[i] = ec._AssetHolding_amount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "id":
			out.Values[i] = ec._AssetHolding_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "asset":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AssetHolding_asset(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "creator":
			out.Values[i] = ec._AssetHolding_creator(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "deleted":
			out.Values[i] = ec._AssetHolding_deleted(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "frozen":
			out.Values[i] = ec._AssetHolding_frozen(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "optedInAtRound":
			out.Values[i] = ec._AssetHolding_optedInAtRound(ctx, field, obj)
		case "optedOutAtRound":
			out.Values[i] = ec._AssetHolding_optedOutAtRound(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var assetParamsImplementors = []string{"AssetParams"}

func (ec *executionContext) _AssetParams(ctx context.Context, sel ast.SelectionSet, obj *model.AssetParams) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, assetParamsImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AssetParams")
		case "clawback":
			out.Values[i] = ec._AssetParams_clawback(ctx, field, obj)
		case "clawbackAccount":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AssetParams_clawbackAccount(ctx, field, obj)
				return res
			})
		case "creator":
			out.Values[i] = ec._AssetParams_creator(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "creatorAccount":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AssetParams_creatorAccount(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "decimals":
			out.Values[i] = ec._AssetParams_decimals(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "defaultFrozen":
			out.Values[i] = ec._AssetParams_defaultFrozen(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "freeze":
			out.Values[i] = ec._AssetParams_freeze(ctx, field, obj)
		case "freezeAccount":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AssetParams_freezeAccount(ctx, field, obj)
				return res
			})
		case "manager":
			out.Values[i] = ec._AssetParams_manager(ctx, field, obj)
		case "managerAccount":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AssetParams_managerAccount(ctx, field, obj)
				return res
			})
		case "metadataHash":
			out.Values[i] = ec._AssetParams_metadataHash(ctx, field, obj)
		case "name":
			out.Values[i] = ec._AssetParams_name(ctx, field, obj)
		case "reserve":
			out.Values[i] = ec._AssetParams_reserve(ctx, field, obj)
		case "reserveAccount":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AssetParams_reserveAccount(ctx, field, obj)
				return res
			})
		case "total":
			out.Values[i] = ec._AssetParams_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "unitName":
			out.Values[i] = ec._AssetParams_unitName(ctx, field, obj)
		case "url":
			out.Values[i] = ec._AssetParams_url(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var assetResponseImplementors = []string{"AssetResponse"}

func (ec *executionContext) _AssetResponse(ctx context.Context, sel ast.SelectionSet, obj *model.AssetResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, assetResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AssetResponse")
		case "asset":
			out.Values[i] = ec._AssetResponse_asset(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "currentRound":
			out.Values[i] = ec._AssetResponse_currentRound(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var assetsResponseImplementors = []string{"AssetsResponse"}

func (ec *executionContext) _AssetsResponse(ctx context.Context, sel ast.SelectionSet, obj *model.AssetsResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, assetsResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AssetsResponse")
		case "assets":
			out.Values[i] = ec._AssetsResponse_assets(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "currentRound":
			out.Values[i] = ec._AssetsResponse_currentRound(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "nextToken":
			out.Values[i] = ec._AssetsResponse_nextToken(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var blockImplementors = []string{"Block"}

func (ec *executionContext) _Block(ctx context.Context, sel ast.SelectionSet, obj *model.Block) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, blockImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Block")
		case "genesisHash":
			out.Values[i] = ec._Block_genesisHash(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "genesisId":
			out.Values[i] = ec._Block_genesisId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "previousBlockHash":
			out.Values[i] = ec._Block_previousBlockHash(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "rewards":
			out.Values[i] = ec._Block_rewards(ctx, field, obj)
		case "round":
			out.Values[i] = ec._Block_round(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "seed":
			out.Values[i] = ec._Block_seed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "timestamp":
			out.Values[i] = ec._Block_timestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "transactions":
			out.Values[i] = ec._Block_transactions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "transactionsRoot":
			out.Values[i] = ec._Block_transactionsRoot(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "txnCounter":
			out.Values[i] = ec._Block_txnCounter(ctx, field, obj)
		case "upgradeState":
			out.Values[i] = ec._Block_upgradeState(ctx, field, obj)
		case "upgradeVote":
			out.Values[i] = ec._Block_upgradeVote(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var blockRewardsImplementors = []string{"BlockRewards"}

func (ec *executionContext) _BlockRewards(ctx context.Context, sel ast.SelectionSet, obj *model.BlockRewards) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, blockRewardsImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BlockRewards")
		case "feeSink":
			out.Values[i] = ec._BlockRewards_feeSink(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "rewardsCalculationRound":
			out.Values[i] = ec._BlockRewards_rewardsCalculationRound(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "rewardsLevel":
			out.Values[i] = ec._BlockRewards_rewardsLevel(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "rewardsPool":
			out.Values[i] = ec._BlockRewards_rewardsPool(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "rewardsRate":
			out.Values[i] = ec._BlockRewards_rewardsRate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "rewardsResidue":
			out.Values[i] = ec._BlockRewards_rewardsResidue(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var blockUpgradeStateImplementors = []string{"BlockUpgradeState"}

func (ec *executionContext) _BlockUpgradeState(ctx context.Context, sel ast.SelectionSet, obj *model.BlockUpgradeState) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, blockUpgradeStateImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BlockUpgradeState")
		case "currentProtocol":
			out.Values[i] = ec._BlockUpgradeState_currentProtocol(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "nextProtocol":
			out.Values[i] = ec._BlockUpgradeState_nextProtocol(ctx, field, obj)
		case "nextProtocolApprovals":
			out.Values[i] = ec._BlockUpgradeState_nextProtocolApprovals(ctx, field, obj)
		case "nextProtocolSwitchOn":
			out.Values[i] = ec._BlockUpgradeState_nextProtocolSwitchOn(ctx, field, obj)
		case "nextProtocolVoteBefore":
			out.Values[i] = ec._BlockUpgradeState_nextProtocolVoteBefore(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var blockUpgradeVoteImplementors = []string{"BlockUpgradeVote"}

func (ec *executionContext) _BlockUpgradeVote(ctx context.Context, sel ast.SelectionSet, obj *model.BlockUpgradeVote) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, blockUpgradeVoteImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BlockUpgradeVote")
		case "upgradeApprove":
			out.Values[i] = ec._BlockUpgradeVote_upgradeApprove(ctx, field, obj)
		case "upgradeDelay":
			out.Values[i] = ec._BlockUpgradeVote_upgradeDelay(ctx, field, obj)
		case "upgradePropose":
			out.Values[i] = ec._BlockUpgradeVote_upgradePropose(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var evalDeltaImplementors = []string{"EvalDelta"}

func (ec *executionContext) _EvalDelta(ctx context.Context, sel ast.SelectionSet, obj *model.EvalDelta) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, evalDeltaImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EvalDelta")
		case "action":
			out.Values[i] = ec._EvalDelta_action(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "bytes":
			out.Values[i] = ec._EvalDelta_bytes(ctx, field, obj)
		case "uint":
			out.Values[i] = ec._EvalDelta_uint(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var evalDeltaKeyValueImplementors = []string{"EvalDeltaKeyValue"}

func (ec *executionContext) _EvalDeltaKeyValue(ctx context.Context, sel ast.SelectionSet, obj *model.EvalDeltaKeyValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, evalDeltaKeyValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EvalDeltaKeyValue")
		case "key":
			out.Values[i] = ec._EvalDeltaKeyValue_key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "value":
			out.Values[i] = ec._EvalDeltaKeyValue_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var healthCheckImplementors = []string{"HealthCheck"}

func (ec *executionContext) _HealthCheck(ctx context.Context, sel ast.SelectionSet, obj *model.HealthCheck) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, healthCheckImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HealthCheck")
		case "data":
			out.Values[i] = ec._HealthCheck_data(ctx, field, obj)
		case "dbAvailable":
			out.Values[i] = ec._HealthCheck_dbAvailable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "errors":
			out.Values[i] = ec._HealthCheck_errors(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isMigrating":
			out.Values[i] = ec._HealthCheck_isMigrating(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "message":
			out.Values[i] = ec._HealthCheck_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "round":
			out.Values[i] = ec._HealthCheck_round(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var miniAssetHoldingImplementors = []string{"MiniAssetHolding"}

func (ec *executionContext) _MiniAssetHolding(ctx context.Context, sel ast.SelectionSet, obj *model.MiniAssetHolding) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, miniAssetHoldingImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MiniAssetHolding")
		case "address":
			out.Values[i] = ec._MiniAssetHolding_address(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "account":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._MiniAssetHolding_account(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "amount":
			out.Values[i] = ec._MiniAssetHolding_amount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "deleted":
			out.Values[i] = ec._MiniAssetHolding_deleted(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "frozen":
			out.Values[i] = ec._MiniAssetHolding_frozen(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "optedInAtRound":
			out.Values[i] = ec._MiniAssetHolding_optedInAtRound(ctx, field, obj)
		case "optedOutAtRound":
			out.Values[i] = ec._MiniAssetHolding_optedOutAtRound(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)

	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "block":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_block(ctx, field)
				return res
			})
		case "healthCheck":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_healthCheck(ctx, field)
				return res
			})
		case "account":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_account(ctx, field)
				return res
			})
		case "accountTransactions":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_accountTransactions(ctx, field)
				return res
			})
		case "accounts":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_accounts(ctx, field)
				return res
			})
		case "application":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_application(ctx, field)
				return res
			})
		case "applications":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_applications(ctx, field)
				return res
			})
		case "asset":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_asset(ctx, field)
				return res
			})
		case "assetBalances":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_assetBalances(ctx, field)
				return res
			})
		case "assetTransactions":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_assetTransactions(ctx, field)
				return res
			})
		case "assets":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_assets(ctx, field)
				return res
			})
		case "transaction":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_transaction(ctx, field)
				return res
			})
		case "transactions":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_transactions(ctx, field)
				return res
			})
		case "__type":
			out.Values[i] = ec._Query___type(ctx, field)
		case "__schema":
			out.Values[i] = ec._Query___schema(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var stateSchemaImplementors = []string{"StateSchema"}

func (ec *executionContext) _StateSchema(ctx context.Context, sel ast.SelectionSet, obj *model.StateSchema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, stateSchemaImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StateSchema")
		case "numByteSlice":
			out.Values[i] = ec._StateSchema_numByteSlice(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "numUint":
			out.Values[i] = ec._StateSchema_numUint(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var subscriptionImplementors = []string{"Subscription"}

func (ec *executionContext) _Subscription(ctx context.Context, sel ast.SelectionSet) func() graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, subscriptionImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Subscription",
	})
	if len(fields) != 1 {
		ec.Errorf(ctx, "must subscribe to exactly one stream")
		return nil
	}

	switch fields[0].Name {
	case "newBlock":
		return ec._Subscription_newBlock(ctx, fields[0])
	case "accountUpdate":
		return ec._Subscription_accountUpdate(ctx, fields[0])
	default:
		panic("unknown field " + strconv.Quote(fields[0].Name))
	}
}

var tealKeyValueImplementors = []string{"TealKeyValue"}

func (ec *executionContext) _TealKeyValue(ctx context.Context, sel ast.SelectionSet, obj *model.TealKeyValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tealKeyValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TealKeyValue")
		case "key":
			out.Values[i] = ec._TealKeyValue_key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "value":
			out.Values[i] = ec._TealKeyValue_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var tealValueImplementors = []string{"TealValue"}

func (ec *executionContext) _TealValue(ctx context.Context, sel ast.SelectionSet, obj *model.TealValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tealValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TealValue")
		case "bytes":
			out.Values[i] = ec._TealValue_bytes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":
			out.Values[i] = ec._TealValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "uint":
			out.Values[i] = ec._TealValue_uint(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var transactionImplementors = []string{"Transaction"}

func (ec *executionContext) _Transaction(ctx context.Context, sel ast.SelectionSet, obj *model.Transaction) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, transactionImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Transaction")
		case "applicationTransaction":
			out.Values[i] = ec._Transaction_applicationTransaction(ctx, field, obj)
		case "assetConfigTransaction":
			out.Values[i] = ec._Transaction_assetConfigTransaction(ctx, field, obj)
		case "assetFreezeTransaction":
			out.Values[i] = ec._Transaction_assetFreezeTransaction(ctx, field, obj)
		case "assetTransferTransaction":
			out.Values[i] = ec._Transaction_assetTransferTransaction(ctx, field, obj)
		case "authAddr":
			out.Values[i] = ec._Transaction_authAddr(ctx, field, obj)
		case "closeRewards":
			out.Values[i] = ec._Transaction_closeRewards(ctx, field, obj)
		case "closingAmount":
			out.Values[i] = ec._Transaction_closingAmount(ctx, field, obj)
		case "confirmedRound":
			out.Values[i] = ec._Transaction_confirmedRound(ctx, field, obj)
		case "createdApplicationId":
			out.Values[i] = ec._Transaction_createdApplicationId(ctx, field, obj)
		case "createdAssetId":
			out.Values[i] = ec._Transaction_createdAssetId(ctx, field, obj)
		case "fee":
			out.Values[i] = ec._Transaction_fee(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "firstValid":
			out.Values[i] = ec._Transaction_firstValid(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "genesisHash":
			out.Values[i] = ec._Transaction_genesisHash(ctx, field, obj)
		case "genesisId":
			out.Values[i] = ec._Transaction_genesisId(ctx, field, obj)
		case "globalStateDelta":
			out.Values[i] = ec._Transaction_globalStateDelta(ctx, field, obj)
		case "group":
			out.Values[i] = ec._Transaction_group(ctx, field, obj)
		case "id":
			out.Values[i] = ec._Transaction_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "intraRoundOffset":
			out.Values[i] = ec._Transaction_intraRoundOffset(ctx, field, obj)
		case "keyregTransaction":
			out.Values[i] = ec._Transaction_keyregTransaction(ctx, field, obj)
		case "lastValid":
			out.Values[i] = ec._Transaction_lastValid(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "lease":
			out.Values[i] = ec._Transaction_lease(ctx, field, obj)
		case "localStateDelta":
			out.Values[i] = ec._Transaction_localStateDelta(ctx, field, obj)
		case "note":
			out.Values[i] = ec._Transaction_note(ctx, field, obj)
		case "paymentTransaction":
			out.Values[i] = ec._Transaction_paymentTransaction(ctx, field, obj)
		case "receiverRewards":
			out.Values[i] = ec._Transaction_receiverRewards(ctx, field, obj)
		case "rekeyTo":
			out.Values[i] = ec._Transaction_rekeyTo(ctx, field, obj)
		case "roundTime":
			out.Values[i] = ec._Transaction_roundTime(ctx, field, obj)
		case "sender":
			out.Values[i] = ec._Transaction_sender(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "senderRewards":
			out.Values[i] = ec._Transaction_senderRewards(ctx, field, obj)
		case "signature":
			out.Values[i] = ec._Transaction_signature(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "txType":
			out.Values[i] = ec._Transaction_txType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var transactionApplicationImplementors = []string{"TransactionApplication"}

func (ec *executionContext) _TransactionApplication(ctx context.Context, sel ast.SelectionSet, obj *model.TransactionApplication) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, transactionApplicationImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TransactionApplication")
		case "accounts":
			out.Values[i] = ec._TransactionApplication_accounts(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "applicationArgs":
			out.Values[i] = ec._TransactionApplication_applicationArgs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "applicationId":
			out.Values[i] = ec._TransactionApplication_applicationId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "approvalProgram":
			out.Values[i] = ec._TransactionApplication_approvalProgram(ctx, field, obj)
		case "clearStateProgram":
			out.Values[i] = ec._TransactionApplication_clearStateProgram(ctx, field, obj)
		case "extraProgramPages":
			out.Values[i] = ec._TransactionApplication_extraProgramPages(ctx, field, obj)
		case "foreignApps":
			out.Values[i] = ec._TransactionApplication_foreignApps(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "foreignAssets":
			out.Values[i] = ec._TransactionApplication_foreignAssets(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "globalStateSchema":
			out.Values[i] = ec._TransactionApplication_globalStateSchema(ctx, field, obj)
		case "localStateSchema":
			out.Values[i] = ec._TransactionApplication_localStateSchema(ctx, field, obj)
		case "onCompletion":
			out.Values[i] = ec._TransactionApplication_onCompletion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var transactionAssetConfigImplementors = []string{"TransactionAssetConfig"}

func (ec *executionContext) _TransactionAssetConfig(ctx context.Context, sel ast.SelectionSet, obj *model.TransactionAssetConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, transactionAssetConfigImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TransactionAssetConfig")
		case "assetId":
			out.Values[i] = ec._TransactionAssetConfig_assetId(ctx, field, obj)
		case "params":
			out.Values[i] = ec._TransactionAssetConfig_params(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var transactionAssetFreezeImplementors = []string{"TransactionAssetFreeze"}

func (ec *executionContext) _TransactionAssetFreeze(ctx context.Context, sel ast.SelectionSet, obj *model.TransactionAssetFreeze) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, transactionAssetFreezeImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TransactionAssetFreeze")
		case "address":
			out.Values[i] = ec._TransactionAssetFreeze_address(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "assetId":
			out.Values[i] = ec._TransactionAssetFreeze_assetId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "newFreezeStatus":
			out.Values[i] = ec._TransactionAssetFreeze_newFreezeStatus(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var transactionAssetTransferImplementors = []string{"TransactionAssetTransfer"}

func (ec *executionContext) _TransactionAssetTransfer(ctx context.Context, sel ast.SelectionSet, obj *model.TransactionAssetTransfer) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, transactionAssetTransferImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TransactionAssetTransfer")
		case "amount":
			out.Values[i] = ec._TransactionAssetTransfer_amount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "assetId":
			out.Values[i] = ec._TransactionAssetTransfer_assetId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "closeAmount":
			out.Values[i] = ec._TransactionAssetTransfer_closeAmount(ctx, field, obj)
		case "closeTo":
			out.Values[i] = ec._TransactionAssetTransfer_closeTo(ctx, field, obj)
		case "receiver":
			out.Values[i] = ec._TransactionAssetTransfer_receiver(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "sender":
			out.Values[i] = ec._TransactionAssetTransfer_sender(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var transactionKeyregImplementors = []string{"TransactionKeyreg"}

func (ec *executionContext) _TransactionKeyreg(ctx context.Context, sel ast.SelectionSet, obj *model.TransactionKeyreg) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, transactionKeyregImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TransactionKeyreg")
		case "nonParticipation":
			out.Values[i] = ec._TransactionKeyreg_nonParticipation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "selectionParticipationKey":
			out.Values[i] = ec._TransactionKeyreg_selectionParticipationKey(ctx, field, obj)
		case "voteFirstValid":
			out.Values[i] = ec._TransactionKeyreg_voteFirstValid(ctx, field, obj)
		case "voteKeyDilution":
			out.Values[i] = ec._TransactionKeyreg_voteKeyDilution(ctx, field, obj)
		case "voteLastValid":
			out.Values[i] = ec._TransactionKeyreg_voteLastValid(ctx, field, obj)
		case "voteParticipationKey":
			out.Values[i] = ec._TransactionKeyreg_voteParticipationKey(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var transactionPaymentImplementors = []string{"TransactionPayment"}

func (ec *executionContext) _TransactionPayment(ctx context.Context, sel ast.SelectionSet, obj *model.TransactionPayment) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, transactionPaymentImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TransactionPayment")
		case "amount":
			out.Values[i] = ec._TransactionPayment_amount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "closeAmount":
			out.Values[i] = ec._TransactionPayment_closeAmount(ctx, field, obj)
		case "closeRemainderTo":
			out.Values[i] = ec._TransactionPayment_closeRemainderTo(ctx, field, obj)
		case "receiver":
			out.Values[i] = ec._TransactionPayment_receiver(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var transactionResponseImplementors = []string{"TransactionResponse"}

func (ec *executionContext) _TransactionResponse(ctx context.Context, sel ast.SelectionSet, obj *model.TransactionResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, transactionResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TransactionResponse")
		case "currentRound":
			out.Values[i] = ec._TransactionResponse_currentRound(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "transaction":
			out.Values[i] = ec._TransactionResponse_transaction(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var transactionSignatureImplementors = []string{"TransactionSignature"}

func (ec *executionContext) _TransactionSignature(ctx context.Context, sel ast.SelectionSet, obj *model.TransactionSignature) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, transactionSignatureImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TransactionSignature")
		case "logicsig":
			out.Values[i] = ec._TransactionSignature_logicsig(ctx, field, obj)
		case "multisig":
			out.Values[i] = ec._TransactionSignature_multisig(ctx, field, obj)
		case "sig":
			out.Values[i] = ec._TransactionSignature_sig(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var transactionSignatureLogicsigImplementors = []string{"TransactionSignatureLogicsig"}

func (ec *executionContext) _TransactionSignatureLogicsig(ctx context.Context, sel ast.SelectionSet, obj *model.TransactionSignatureLogicsig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, transactionSignatureLogicsigImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TransactionSignatureLogicsig")
		case "args":
			out.Values[i] = ec._TransactionSignatureLogicsig_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "logic":
			out.Values[i] = ec._TransactionSignatureLogicsig_logic(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "multisigSignature":
			out.Values[i] = ec._TransactionSignatureLogicsig_multisigSignature(ctx, field, obj)
		case "signature":
			out.Values[i] = ec._TransactionSignatureLogicsig_signature(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var transactionSignatureMultisigImplementors = []string{"TransactionSignatureMultisig"}

func (ec *executionContext) _TransactionSignatureMultisig(ctx context.Context, sel ast.SelectionSet, obj *model.TransactionSignatureMultisig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, transactionSignatureMultisigImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TransactionSignatureMultisig")
		case "subsignature":
			out.Values[i] = ec._TransactionSignatureMultisig_subsignature(ctx, field, obj)
		case "threshold":
			out.Values[i] = ec._TransactionSignatureMultisig_threshold(ctx, field, obj)
		case "version":
			out.Values[i] = ec._TransactionSignatureMultisig_version(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var transactionSignatureMultisigSubsignatureImplementors = []string{"TransactionSignatureMultisigSubsignature"}

func (ec *executionContext) _TransactionSignatureMultisigSubsignature(ctx context.Context, sel ast.SelectionSet, obj *model.TransactionSignatureMultisigSubsignature) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, transactionSignatureMultisigSubsignatureImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TransactionSignatureMultisigSubsignature")
		case "publicKey":
			out.Values[i] = ec._TransactionSignatureMultisigSubsignature_publicKey(ctx, field, obj)
		case "signature":
			out.Values[i] = ec._TransactionSignatureMultisigSubsignature_signature(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var transactionsResponseImplementors = []string{"TransactionsResponse"}

func (ec *executionContext) _TransactionsResponse(ctx context.Context, sel ast.SelectionSet, obj *model.TransactionsResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, transactionsResponseImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TransactionsResponse")
		case "currentRound":
			out.Values[i] = ec._TransactionsResponse_currentRound(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "nextToken":
			out.Values[i] = ec._TransactionsResponse_nextToken(ctx, field, obj)
		case "transactions":
			out.Values[i] = ec._TransactionsResponse_transactions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) marshalNAccount2githubcomalgorandindexerapigraphmodelAccount(ctx context.Context, sel ast.SelectionSet, v model.Account) graphql.Marshaler {
	return ec._Account(ctx, sel, &v)
}

func (ec *executionContext) marshalNAccount2githubcomalgorandindexerapigraphmodelAccount(ctx context.Context, sel ast.SelectionSet, v []model.Account) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAccount2githubcomalgorandindexerapigraphmodelAccount(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNAccount2githubcomalgorandindexerapigraphmodelAccount(ctx context.Context, sel ast.SelectionSet, v *model.Account) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Account(ctx, sel, v)
}

func (ec *executionContext) marshalNAccountStateDelta2githubcomalgorandindexerapigraphmodelAccountStateDelta(ctx context.Context, sel ast.SelectionSet, v model.AccountStateDelta) graphql.Marshaler {
	return ec._AccountStateDelta(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNAccountStatus2githubcomalgorandindexerapigraphmodelAccountStatus(ctx context.Context, v interface{}) (model.AccountStatus, error) {
	var res model.AccountStatus
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAccountStatus2githubcomalgorandindexerapigraphmodelAccountStatus(ctx context.Context, sel ast.SelectionSet, v model.AccountStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNAddress2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAddress2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNAddress2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNAddress2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNAddress2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNAddress2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) marshalNApplication2githubcomalgorandindexerapigraphmodelApplication(ctx context.Context, sel ast.SelectionSet, v model.Application) graphql.Marshaler {
	return ec._Application(ctx, sel, &v)
}

func (ec *executionContext) marshalNApplication2githubcomalgorandindexerapigraphmodelApplication(ctx context.Context, sel ast.SelectionSet, v []model.Application) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNApplication2githubcomalgorandindexerapigraphmodelApplication(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNApplication2githubcomalgorandindexerapigraphmodelApplication(ctx context.Context, sel ast.SelectionSet, v *model.Application) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Application(ctx, sel, v)
}

func (ec *executionContext) marshalNApplicationLocalState2githubcomalgorandindexerapigraphmodelApplicationLocalState(ctx context.Context, sel ast.SelectionSet, v model.ApplicationLocalState) graphql.Marshaler {
	return ec._ApplicationLocalState(ctx, sel, &v)
}

func (ec *executionContext) marshalNApplicationLocalState2githubcomalgorandindexerapigraphmodelApplicationLocalState(ctx context.Context, sel ast.SelectionSet, v []model.ApplicationLocalState) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNApplicationLocalState2githubcomalgorandindexerapigraphmodelApplicationLocalState(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNApplicationParams2githubcomalgorandindexerapigraphmodelApplicationParams(ctx context.Context, sel ast.SelectionSet, v *model.ApplicationParams) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ApplicationParams(ctx, sel, v)
}

func (ec *executionContext) marshalNApplicationStateSchema2githubcomalgorandindexerapigraphmodelApplicationStateSchema(ctx context.Context, sel ast.SelectionSet, v *model.ApplicationStateSchema) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ApplicationStateSchema(ctx, sel, v)
}

func (ec *executionContext) marshalNAsset2githubcomalgorandindexerapigraphmodelAsset(ctx context.Context, sel ast.SelectionSet, v model.Asset) graphql.Marshaler {
	return ec._Asset(ctx, sel, &v)
}

func (ec *executionContext) marshalNAsset2githubcomalgorandindexerapigraphmodelAsset(ctx context.Context, sel ast.SelectionSet, v []model.Asset) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAsset2githubcomalgorandindexerapigraphmodelAsset(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNAsset2githubcomalgorandindexerapigraphmodelAsset(ctx context.Context, sel ast.SelectionSet, v *model.Asset) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Asset(ctx, sel, v)
}

func (ec *executionContext) marshalNAssetHolding2githubcomalgorandindexerapigraphmodelAssetHolding(ctx context.Context, sel ast.SelectionSet, v model.AssetHolding) graphql.Marshaler {
	return ec._AssetHolding(ctx, sel, &v)
}

func (ec *executionContext) marshalNAssetHolding2githubcomalgorandindexerapigraphmodelAssetHolding(ctx context.Context, sel ast.SelectionSet, v []model.AssetHolding) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAssetHolding2githubcomalgorandindexerapigraphmodelAssetHolding(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNAssetParams2githubcomalgorandindexerapigraphmodelAssetParams(ctx context.Context, sel ast.SelectionSet, v *model.AssetParams) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._AssetParams(ctx, sel, v)
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNBytes2byte(ctx context.Context, v interface{}) ([]byte, error) {
	res, err := model.UnmarshalBytes(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBytes2byte(ctx context.Context, sel ast.SelectionSet, v []byte) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := model.MarshalBytes(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNBytes2byte(ctx context.Context, v interface{}) ([][]byte, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([][]byte, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNBytes2byte(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNBytes2byte(ctx context.Context, sel ast.SelectionSet, v [][]byte) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNBytes2byte(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalNDeltaAction2githubcomalgorandindexerapigraphmodelDeltaAction(ctx context.Context, v interface{}) (model.DeltaAction, error) {
	var res model.DeltaAction
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDeltaAction2githubcomalgorandindexerapigraphmodelDeltaAction(ctx context.Context, sel ast.SelectionSet, v model.DeltaAction) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNEvalDelta2githubcomalgorandindexerapigraphmodelEvalDelta(ctx context.Context, sel ast.SelectionSet, v *model.EvalDelta) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._EvalDelta(ctx, sel, v)
}

func (ec *executionContext) marshalNEvalDeltaKeyValue2githubcomalgorandindexerapigraphmodelEvalDeltaKeyValue(ctx context.Context, sel ast.SelectionSet, v model.EvalDeltaKeyValue) graphql.Marshaler {
	return ec._EvalDeltaKeyValue(ctx, sel, &v)
}

func (ec *executionContext) marshalNEvalDeltaKeyValue2githubcomalgorandindexerapigraphmodelEvalDeltaKeyValue(ctx context.Context, sel ast.SelectionSet, v []model.EvalDeltaKeyValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNEvalDeltaKeyValue2githubcomalgorandindexerapigraphmodelEvalDeltaKeyValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNMiniAssetHolding2githubcomalgorandindexerapigraphmodelMiniAssetHolding(ctx context.Context, sel ast.SelectionSet, v model.MiniAssetHolding) graphql.Marshaler {
	return ec._MiniAssetHolding(ctx, sel, &v)
}

func (ec *executionContext) marshalNMiniAssetHolding2githubcomalgorandindexerapigraphmodelMiniAssetHolding(ctx context.Context, sel ast.SelectionSet, v []model.MiniAssetHolding) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMiniAssetHolding2githubcomalgorandindexerapigraphmodelMiniAssetHolding(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNOnCompletion2githubcomalgorandindexerapigraphmodelOnCompletion(ctx context.Context, v interface{}) (model.OnCompletion, error) {
	var res model.OnCompletion
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNOnCompletion2githubcomalgorandindexerapigraphmodelOnCompletion(ctx context.Context, sel ast.SelectionSet, v model.OnCompletion) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) marshalNTealKeyValue2githubcomalgorandindexerapigraphmodelTealKeyValue(ctx context.Context, sel ast.SelectionSet, v model.TealKeyValue) graphql.Marshaler {
	return ec._TealKeyValue(ctx, sel, &v)
}

func (ec *executionContext) marshalNTealKeyValue2githubcomalgorandindexerapigraphmodelTealKeyValue(ctx context.Context, sel ast.SelectionSet, v []model.TealKeyValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTealKeyValue2githubcomalgorandindexerapigraphmodelTealKeyValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNTealValue2githubcomalgorandindexerapigraphmodelTealValue(ctx context.Context, sel ast.SelectionSet, v *model.TealValue) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._TealValue(ctx, sel, v)
}

func (ec *executionContext) marshalNTransaction2githubcomalgorandindexerapigraphmodelTransaction(ctx context.Context, sel ast.SelectionSet, v model.Transaction) graphql.Marshaler {
	return ec._Transaction(ctx, sel, &v)
}

func (ec *executionContext) marshalNTransaction2githubcomalgorandindexerapigraphmodelTransaction(ctx context.Context, sel ast.SelectionSet, v []model.Transaction) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTransaction2githubcomalgorandindexerapigraphmodelTransaction(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNTransaction2githubcomalgorandindexerapigraphmodelTransaction(ctx context.Context, sel ast.SelectionSet, v *model.Transaction) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Transaction(ctx, sel, v)
}

func (ec *executionContext) marshalNTransactionSignature2githubcomalgorandindexerapigraphmodelTransactionSignature(ctx context.Context, sel ast.SelectionSet, v *model.TransactionSignature) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._TransactionSignature(ctx, sel, v)
}

func (ec *executionContext) marshalNTransactionSignatureMultisigSubsignature2githubcomalgorandindexerapigraphmodelTransactionSignatureMultisigSubsignature(ctx context.Context, sel ast.SelectionSet, v model.TransactionSignatureMultisigSubsignature) graphql.Marshaler {
	return ec._TransactionSignatureMultisigSubsignature(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNTxType2githubcomalgorandindexerapigraphmodelTxType(ctx context.Context, v interface{}) (model.TxType, error) {
	var res model.TxType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTxType2githubcomalgorandindexerapigraphmodelTxType(ctx context.Context, sel ast.SelectionSet, v model.TxType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNUint642uint64(ctx context.Context, v interface{}) (uint64, error) {
	res, err := model.UnmarshalUint64(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUint642uint64(ctx context.Context, sel ast.SelectionSet, v uint64) graphql.Marshaler {
	res := model.MarshalUint64(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNUint642uint64(ctx context.Context, v interface{}) ([]uint64, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]uint64, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNUint642uint64(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNUint642uint64(ctx context.Context, sel ast.SelectionSet, v []uint64) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNUint642uint64(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalOAccount2githubcomalgorandindexerapigraphmodelAccount(ctx context.Context, sel ast.SelectionSet, v *model.Account) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Account(ctx, sel, v)
}

func (ec *executionContext) marshalOAccountParticipation2githubcomalgorandindexerapigraphmodelAccountParticipation(ctx context.Context, sel ast.SelectionSet, v *model.AccountParticipation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AccountParticipation(ctx, sel, v)
}

func (ec *executionContext) marshalOAccountResponse2githubcomalgorandindexerapigraphmodelAccountResponse(ctx context.Context, sel ast.SelectionSet, v *model.AccountResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AccountResponse(ctx, sel, v)
}

func (ec *executionContext) marshalOAccountStateDelta2githubcomalgorandindexerapigraphmodelAccountStateDelta(ctx context.Context, sel ast.SelectionSet, v []model.AccountStateDelta) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAccountStateDelta2githubcomalgorandindexerapigraphmodelAccountStateDelta(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOAccountUpdateResponse2githubcomalgorandindexerapigraphmodelAccountUpdateResponse(ctx context.Context, sel ast.SelectionSet, v *model.AccountUpdateResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AccountUpdateResponse(ctx, sel, v)
}

func (ec *executionContext) marshalOAccountsResponse2githubcomalgorandindexerapigraphmodelAccountsResponse(ctx context.Context, sel ast.SelectionSet, v *model.AccountsResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AccountsResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalOAddress2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOAddress2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*v)
}

func (ec *executionContext) unmarshalOAddressRole2githubcomalgorandindexerapigraphmodelAddressRole(ctx context.Context, v interface{}) (*model.AddressRole, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.AddressRole)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOAddressRole2githubcomalgorandindexerapigraphmodelAddressRole(ctx context.Context, sel ast.SelectionSet, v *model.AddressRole) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOApplication2githubcomalgorandindexerapigraphmodelApplication(ctx context.Context, sel ast.SelectionSet, v *model.Application) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Application(ctx, sel, v)
}

func (ec *executionContext) marshalOApplicationLocalState2githubcomalgorandindexerapigraphmodelApplicationLocalState(ctx context.Context, sel ast.SelectionSet, v *model.ApplicationLocalState) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ApplicationLocalState(ctx, sel, v)
}

func (ec *executionContext) marshalOApplicationResponse2githubcomalgorandindexerapigraphmodelApplicationResponse(ctx context.Context, sel ast.SelectionSet, v *model.ApplicationResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ApplicationResponse(ctx, sel, v)
}

func (ec *executionContext) marshalOApplicationsResponse2githubcomalgorandindexerapigraphmodelApplicationsResponse(ctx context.Context, sel ast.SelectionSet, v *model.ApplicationsResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ApplicationsResponse(ctx, sel, v)
}

func (ec *executionContext) marshalOAsset2githubcomalgorandindexerapigraphmodelAsset(ctx context.Context, sel ast.SelectionSet, v *model.Asset) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Asset(ctx, sel, v)
}

func (ec *executionContext) marshalOAssetBalancesResponse2githubcomalgorandindexerapigraphmodelAssetBalancesResponse(ctx context.Context, sel ast.SelectionSet, v *model.AssetBalancesResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AssetBalancesResponse(ctx, sel, v)
}

func (ec *executionContext) marshalOAssetHolding2githubcomalgorandindexerapigraphmodelAssetHolding(ctx context.Context, sel ast.SelectionSet, v *model.AssetHolding) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AssetHolding(ctx, sel, v)
}

func (ec *executionContext) marshalOAssetParams2githubcomalgorandindexerapigraphmodelAssetParams(ctx context.Context, sel ast.SelectionSet, v *model.AssetParams) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AssetParams(ctx, sel, v)
}

func (ec *executionContext) marshalOAssetResponse2githubcomalgorandindexerapigraphmodelAssetResponse(ctx context.Context, sel ast.SelectionSet, v *model.AssetResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AssetResponse(ctx, sel, v)
}

func (ec *executionContext) marshalOAssetsResponse2githubcomalgorandindexerapigraphmodelAssetsResponse(ctx context.Context, sel ast.SelectionSet, v *model.AssetsResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AssetsResponse(ctx, sel, v)
}

func (ec *executionContext) marshalOBlock2githubcomalgorandindexerapigraphmodelBlock(ctx context.Context, sel ast.SelectionSet, v *model.Block) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Block(ctx, sel, v)
}

func (ec *executionContext) marshalOBlockRewards2githubcomalgorandindexerapigraphmodelBlockRewards(ctx context.Context, sel ast.SelectionSet, v *model.BlockRewards) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._BlockRewards(ctx, sel, v)
}

func (ec *executionContext) marshalOBlockUpgradeState2githubcomalgorandindexerapigraphmodelBlockUpgradeState(ctx context.Context, sel ast.SelectionSet, v *model.BlockUpgradeState) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._BlockUpgradeState(ctx, sel, v)
}

func (ec *executionContext) marshalOBlockUpgradeVote2githubcomalgorandindexerapigraphmodelBlockUpgradeVote(ctx context.Context, sel ast.SelectionSet, v *model.BlockUpgradeVote) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._BlockUpgradeVote(ctx, sel, v)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	return graphql.MarshalBoolean(v)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return graphql.MarshalBoolean(*v)
}

func (ec *executionContext) unmarshalOBytes2byte(ctx context.Context, v interface{}) ([]byte, error) {
	if v == nil {
		return nil, nil
	}
	res, err := model.UnmarshalBytes(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBytes2byte(ctx context.Context, sel ast.SelectionSet, v []byte) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return model.MarshalBytes(v)
}

func (ec *executionContext) marshalOEvalDeltaKeyValue2githubcomalgorandindexerapigraphmodelEvalDeltaKeyValue(ctx context.Context, sel ast.SelectionSet, v []model.EvalDeltaKeyValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNEvalDeltaKeyValue2githubcomalgorandindexerapigraphmodelEvalDeltaKeyValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOHealthCheck2githubcomalgorandindexerapigraphmodelHealthCheck(ctx context.Context, sel ast.SelectionSet, v *model.HealthCheck) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._HealthCheck(ctx, sel, v)
}

func (ec *executionContext) unmarshalOMap2map(ctx context.Context, v interface{}) (map[string]interface{}, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalMap(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOMap2map(ctx context.Context, sel ast.SelectionSet, v map[string]interface{}) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return graphql.MarshalMap(v)
}

func (ec *executionContext) unmarshalOSigType2githubcomalgorandindexerapigraphmodelSigType(ctx context.Context, v interface{}) (*model.SigType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.SigType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSigType2githubcomalgorandindexerapigraphmodelSigType(ctx context.Context, sel ast.SelectionSet, v *model.SigType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOStateSchema2githubcomalgorandindexerapigraphmodelStateSchema(ctx context.Context, sel ast.SelectionSet, v *model.StateSchema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._StateSchema(ctx, sel, v)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*v)
}

func (ec *executionContext) marshalOTealKeyValue2githubcomalgorandindexerapigraphmodelTealKeyValue(ctx context.Context, sel ast.SelectionSet, v []model.TealKeyValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTealKeyValue2githubcomalgorandindexerapigraphmodelTealKeyValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOTime2timeTime(ctx context.Context, v interface{}) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalTime(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2timeTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return graphql.MarshalTime(*v)
}

func (ec *executionContext) marshalOTransactionApplication2githubcomalgorandindexerapigraphmodelTransactionApplication(ctx context.Context, sel ast.SelectionSet, v *model.TransactionApplication) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TransactionApplication(ctx, sel, v)
}

func (ec *executionContext) marshalOTransactionAssetConfig2githubcomalgorandindexerapigraphmodelTransactionAssetConfig(ctx context.Context, sel ast.SelectionSet, v *model.TransactionAssetConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TransactionAssetConfig(ctx, sel, v)
}

func (ec *executionContext) marshalOTransactionAssetFreeze2githubcomalgorandindexerapigraphmodelTransactionAssetFreeze(ctx context.Context, sel ast.SelectionSet, v *model.TransactionAssetFreeze) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TransactionAssetFreeze(ctx, sel, v)
}

func (ec *executionContext) marshalOTransactionAssetTransfer2githubcomalgorandindexerapigraphmodelTransactionAssetTransfer(ctx context.Context, sel ast.SelectionSet, v *model.TransactionAssetTransfer) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TransactionAssetTransfer(ctx, sel, v)
}

func (ec *executionContext) marshalOTransactionKeyreg2githubcomalgorandindexerapigraphmodelTransactionKeyreg(ctx context.Context, sel ast.SelectionSet, v *model.TransactionKeyreg) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TransactionKeyreg(ctx, sel, v)
}

func (ec *executionContext) marshalOTransactionPayment2githubcomalgorandindexerapigraphmodelTransactionPayment(ctx context.Context, sel ast.SelectionSet, v *model.TransactionPayment) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TransactionPayment(ctx, sel, v)
}

func (ec *executionContext) marshalOTransactionResponse2githubcomalgorandindexerapigraphmodelTransactionResponse(ctx context.Context, sel ast.SelectionSet, v *model.TransactionResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TransactionResponse(ctx, sel, v)
}

func (ec *executionContext) marshalOTransactionSignatureLogicsig2githubcomalgorandindexerapigraphmodelTransactionSignatureLogicsig(ctx context.Context, sel ast.SelectionSet, v *model.TransactionSignatureLogicsig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TransactionSignatureLogicsig(ctx, sel, v)
}

func (ec *executionContext) marshalOTransactionSignatureMultisig2githubcomalgorandindexerapigraphmodelTransactionSignatureMultisig(ctx context.Context, sel ast.SelectionSet, v *model.TransactionSignatureMultisig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TransactionSignatureMultisig(ctx, sel, v)
}

func (ec *executionContext) marshalOTransactionSignatureMultisigSubsignature2githubcomalgorandindexerapigraphmodelTransactionSignatureMultisigSubsignature(ctx context.Context, sel ast.SelectionSet, v []model.TransactionSignatureMultisigSubsignature) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTransactionSignatureMultisigSubsignature2githubcomalgorandindexerapigraphmodelTransactionSignatureMultisigSubsignature(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOTransactionsResponse2githubcomalgorandindexerapigraphmodelTransactionsResponse(ctx context.Context, sel ast.SelectionSet, v *model.TransactionsResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TransactionsResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTxType2githubcomalgorandindexerapigraphmodelTxType(ctx context.Context, v interface{}) (*model.TxType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.TxType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTxType2githubcomalgorandindexerapigraphmodelTxType(ctx context.Context, sel ast.SelectionSet, v *model.TxType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOUint642uint64(ctx context.Context, v interface{}) (*uint64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := model.UnmarshalUint64(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUint642uint64(ctx context.Context, sel ast.SelectionSet, v *uint64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return model.MarshalUint64(*v)
}

func (ec *executionContext) marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
